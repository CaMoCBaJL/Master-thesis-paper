\documentclass[master, och, coursework, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}

\usepackage{graphicx}
\usepackage{xcolor}

\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{cmap}
\renewcommand{\rmdefault}{cmr} % Шрифт с засечками
\renewcommand{\sfdefault}{cmss} % Шрифт без засечек
\renewcommand{\ttdefault}{cmtt} % Моноширинный шрифт
\usepackage{tempora}
\usepackage{cite}
\usepackage{multirow}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\definecolor{linkcolor}{HTML}{FF4500}
\hypersetup{pdfstartview=FitH, linkcolor=linkcolor, urlcolor=linkcolor, colorlinks=true}

\addto\captionsrussian{\def\refname{ }}
\linespread{1.6}
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}
\renewcommand*\thesection{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\number\numexpr\value{subsection}\relax}

% ----------------------------------------------------------------
% elResourceRef command
% usage: 
% \elResourceRef{<resource name>}{<url to resource>}{date of the application}
\newcommand{\elResourceRef}[3]{#1 [Электронный ресурс] URL: #2 (дата обращения: #3)}
% ----------------------------------------------------------------
% image command
% usage: 
%\image{<image scale>}{<description text>}
\newcommand{\image}[2]{%
	\begin{center}%
	\label{img\arabic{imgCounter}}%
	\includegraphics[scale = #1]{\arabic{imgCounter}.png}\par%
	Рисунок \arabic{imgCounter} --- #2%
	\addtocounter{imgCounter}{1}%
	\end{center}%
}
%-----------------------------------------------------------------
% addBibItem command
% usage:
% \addBibItem{<\elResourceRef{<resource name>}{<url to resource>}{date of the application}>};
% \addBibItem{<custom item name>}
\newcommand{\addBibItem}[1]{%
\bibitem{Ione}#1%
\label{\arabic{labelCounter}}%
\addtocounter{labelCounter}{1}%
}
%-----------------------------------------------------------------
% sourceRef command
% usage:
% \sourceRef
\newcommand{\sourceRef}{{\cite{master\arabic{hyrefCounter}} \addtocounter{hyrefCounter}{1}}}
%-----------------------------------------------------------------
%custom counters declaration
\newcounter{imgCounter}
\setcounter{imgCounter}{1}
\newcounter{labelCounter}
\setcounter{labelCounter}{1}
\newcounter{hyrefCounter}
\setcounter{hyrefCounter}{1}
%------------------------------------------------------------------

\newtheorem{lem}{Лемма}

\begin{document}
\lstset{basicstyle = \small}
% Кафедра (в родительном падеже)
\chair{Кафедра информатики и программирования}

% Тема работы
\title{Разработка комплекса автоматизированного тестирования разработаннго транслятора из языка программирования КуМир в язык С++}

% Курс
\course{1}
\group{173}

% Факультет (в родительном падеже)
\department{КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.04 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Пронина Антона Алексеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{М.\,В.\,Огнева}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{старший преподаватель} %должность, степень, звание
\saname{Е.\,Е.\,Лапшева}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{1}
\course{1}
% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{производственная распределенная (научно-исследовательская работа)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{18}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.09.2022}
\practFinish{15.01.2023}


% Наименование практики (только для практики, для остальных
% типов работ не используется)


% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)


% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)


% Год выполнения отчета
\date{2023}

\maketitle
% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering
\tableofcontents


\intro


В современном школьном образовании среди прочих можно выделить следующие тенденции: 
растущий интерес к изучению робототехники;
глубокая интеграция языка программирования КуМир в школьную информатику и государственную итоговую аттестацию по этому предмету.\par
В связи с этим будет востребована система программирования роботов с использованием этого языка программирования. Ключевой составной частью этой системы является транслятор программы с языка КуМир [1] в язык C++. Трубуется протестировать разработанный транслятор, провести поиск ошибок и устранить их. \par
Создание средств и систем обеспечения надежности ПО такого класса как
компиляторы, представляет собой весьма сложную задачу, особенно, если речь идет о тестировании компиляторов. Тестирование компиляторов - это необходимый этап в разработке языков программирования и компиляторов, поскольку компиляторы являются ключевыми инструментами для трансформации исходного кода в машинный код, который может выполняться на целевой платформе. Наличие надежного и качественного компилятора обеспечивает уверенность в правильности работы программ и уменьшает риски возникновения ошибок во время выполнения программы. Тестирование компиляторов необходимо для гарантии совместимости программного кода на различных платформах и операционных системах. Кроме того, тестирование компиляторов помогает в оценке работоспособности и эффективности программного обеспечения на целевой платформе. В целом, тестирование компиляторов является важным этапом в процессе разработке программного обеспечения, который может помочь в достижении более высокого качества и уверенности в работе программного кода.\par
Актуальность транслятора заключается в снижении входного порога в область робототехники как со стороны ученика, предоставляя возможность, используя полученные навыки программирования в системе КуМир, заниматься разработкой роботов, так и со стороны преподавателя, уменьшая затраты на приобретение программных и аппаратных средств разработки. В качестве аппаратной платформы данной задачи был выбран электронный конструктор и удобная платформа быстрой разработки электронных устройств для новичков и профессионалов [2] - платы Arduino. Ввиду низкой стоимости устройств, периферийных модулей, простоты разработки аппаратных устройств на базе этих плат, высокой модульности систем и их высокой распространенности среди робототехников. \par
Цель работы - разработка комплекса автоматизированного тестирования из языка программирования КуМир в язык С++. \par
Для выполнения поставленной цели, требуется выполнить следующие задачи:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item анализ подходов, инструментов и ПО, использующихся при автоматизации тестирования;
\item разработка набора тестов и документации для транслятора;
\item разработка системы автоматизированного тестирования.
\end{itemize}
\section{Методы, средства и технологии}
\subsection{Методы и средства автоматизированного тестирования}
Автоматизированное тестирование - это процесс тестирования, в котором используются специальные программные средства и скрипты, которые могут автоматически создавать и проводить тесты на соответствие функциональным требованиям. Автоматизированный тест позволяет быстро и эффективно производить тестирование без физического участия тестировщика. Это позволяет повысить качество продукта, уменьшить количество ошибок и рисков при релизе, а также быстро и точно проводить регрессионное тестирование после внесения изменений в проект. Автоматизированное тестирование может уменьшить время, необходимое для тестирования, а также заставить взглянуть на проблемы, с которыми можно столкнуться во время процесса разработки.
В качестве основных видов автоматизированного тестирования можно выделить следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item {Unit-тестирование: тестирование отдельных компонентов программного обеспечения, таких как функции, классы и модули;}
\item {интеграционное тестирование: тестирование взаимодействия между отдельными компонентами;}
\item {функциональное тестирование: тестирование функциональности программного обеспечения;}
\item {конфигурационное тестирование: тестирование работоспособности системы при изменении настроек и конфигураций;}
\item {нагрузочное тестирование: тестирование производительности системы при различных нагрузках;}
\item {тестирование безопасности: тестирование на возможность атак и нарушений безопасности системы;}
\item {тестирование совместимости: тестирование возможности программного обеспечения работать с различными операционными системами, браузерами и устройствами;}
\item{тестирование пользовательского интерфейса: тестирование удобства и функциональности интерфейса программного обеспечения;}
\item{автоматизированное тестирование: использование специальных средств для создания скриптов тестирования и автоматизации процесса тестирования.}
\end{itemize} \par
В зависимости от платформы, применяются различные инструменты и методы тестирования. в качестве тестируемого объекта выступает транслятор из языка программирования КуМир в язык С++. \par
При создании системы тестирования, требуется максимально уменьшить количество внешних эффектов, создаваемых окружением. Для унификации среды для запуска системы тестирования используется технология контейнеризации и Docker. \par
Оконтейнеризация (или контейнеризация) - это технология виртуализации, которая позволяет запускать и управлять различными приложениями в изолированной среде - контейнере. Контейнеры являются автономными, портативными и легковесными единицами, которые могут быть запущены в любой совместимой с контейнеризацией среде. \par
Контейнеры позволяют упаковывать приложения и их зависимости в единую единицу, которая может быть развернута и запущена в любом месте, без необходимости инсталляции конкретных зависимостей на хост-системе. Контейнеры дают возможность разработчикам и DevOps-инженерам значительно ускорить процесс разработки, тестирования и распространения приложений. \par
Контейнеры используют ядро операционной системы хоста и создают определенное окружение, в котором приложение запускается и работает. Это облегчает многие процессы, такие как масштабирование, управление зависимостями и обновлениями, управление средой и конфигурацией приложения.\par
Docker - это свободное программное обеспечение, которое позволяет упаковывать, доставлять и запускать приложения в контейнерах. Это популярная технология контейнеризации, которая позволяет разработчикам быстро и легко создавать, тестировать и запускать приложения в различных средах. Docker также предоставляет инструменты для управления контейнерами, включая CLI и API. Это позволяет управлять контейнерами и приложениями из командной строки или с помощью API, что делает автоматизацию и масштабирование процесса разработки и развертывания более эффективным. Docker - это инновационная технология, которая упрощает процессы разработки, тестирования и запуска приложений и может использоваться в любом окружении. Она становится все более популярной в мире разработки приложений благодаря своей надежности, безопасности и высокой скорости запуска. \par
С точки зрения тестирования, транслятор - просто программа, принимающая информацию на вход и в результате работы имеющая определенный выход. Можно выделить 4 основных способа тестирования компиляторов:
\begin{enumerate}
\item наборы небольших статических тестов (regression, unit и т.п.). Это наборы тестов программного обеспечения, которые написаны до запуска приложения и проверяют его на соответствие требованиям и описанию функций. Эти тесты используются для проверки корректности работы приложения до его использования реальными пользователями.;
\item приложения-тестеры. Это приложение позволяет создавать тестовые сценарии, выполнять автоматические тесты и генерировать отчеты о результатах тестирования. Обычно приложения-тестеры используются во время автоматического тестирования, когда тесты выполняются без участия человека. Это может быть полезно для повторяемых тестов, которые нужно проводить на протяжении всего периода разработки приложения;
\item coverage-тестирование. Это метод тестирования программного обеспечения, который позволяет оценить, насколько хорошо тесты покрывают код программы. Он используется для определения того, сколько кода было протестировано путем анализа выполнения тестов и сравнения с фактическим кодом программы. Результаты coverage-тестирования определяют, какие участки кода были покрыты тестами и какие нет. Если некоторые участки кода не были покрыты тестами, то разработчики смогут сосредоточиться на их тестировании и повышении надежности программного обеспечения.;
\item fuzzing-тестирование. Это метод тестирования программного обеспечения, который заключается в автоматической генерации большого количества случайных или полу-случайных входных данных, и последующем анализе ответов на эти входные данные. Целью такого тестирования является обнаружение ошибок и уязвимостей в программном обеспечении, которые могут привести к потенциальным угрозам безопасности или нарушению работоспособности приложения [3].
\end{enumerate}
Среди готовых решений для тестирования ПО можно выделить следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item {IBM Rational Functional Tester[4] предоставляет функции автоматического тестирования для функционального, регрессионного тестирования, тестирования графических пользовательских интерфейсов и тестирования, ориентированного на данные. Данная программа не распространяется бесплатно, для использования необходимо приобрести лицензию;}
\item {IBM Rational Test Workbench[5] так же распространяется по платной лицензией, с пробным периодом бесплатного использования в тридцать дней;}
\item {система автоматизированного тестирования TestComplete[6], \\ предоставляющая в том числе инструмент для регрессионного тестирования.}
\end{itemize}\par
На этапе анализа существующего ПО для тестирования, было выяснено, что ни 1 из рассмотренных вариантов не сможет быть применен в виду чрезмерно объемного интерфейса, а также отсутствия бесплатной подписки. \par
Транслятор из языка программирования КуМир в язык программирования С++ - разработка с открытыми исходными кодами. На данный момент, язык программирования КуМир поддерживает функциональный стиль программирования без создания пользовательских структур или классов.
 Ввиду наличия исходных кодов транслятора и ограниченности набора инструкций языка КуМир, было решено разработать автоматизированную тестовую среду с набором статических тестов.
 \subsection{Транслятор с языка КуМир в язык С++}
Приложение разрабатывается на языке С++ с использованием фрейморвка QT 4 или 5 версии, а также системы автоматизации сборки программного кода CMake. Для сборки проекта на операционной системе Windows, требуется программа-сборщик MS Build 2012, устаревший на данный момент и труднодоступный для скачивания, поэтому было предпринято решение разрабатывать приложение на операционной системе Linux Mint. Для сборки проекта требуется установить ряд дополнительных библиотек, среди которых: ZLib, Boost и интерпретатор языка программирования Python.\par
Проект состоит из ряда библиотек, используемых внутри проекта, в том числе - AST-дерево, библиотека для работы с низкоуровневой виртуальной машиной, библиотеки для рендеринга pdf-документoв и т.д.; плагинов, а также исполнителей и сред разработки, состоящих из файлов с описанием использующихся методов, процедур и сущностей и файлов с описанием слоя представления данных частей. Ввиду большого объема приложения, высокого уровня связности  элементов друг с другом и устаревших библиотек, используемых для разработки, сборка проекта осуществляется при помощи командной строки. \par
В плагине kumirCodeGenerator осуществляется трансляция и компиляция программного кода с языка КуМир в язык низкоуровневой виртуальной машины. По имеющемуся файлу с исходным кодом происходят лексический и синтаксический анализы, в случае, если они завершились успешно и не было выявлено ошибок, трансляция продолжается. В результате лексического анализа имеется набор лексем кода исходного языка программирования, использующийся для синтаксического анализа. В результате синтаксического анализа программа создает набор токенов для генерации по ним дерева разбора. Вычисленное дерево разбора усекается до AST-дерева, для трансляции кода. На этом этапе происходит наращивание кода на выходном языке по имеющемуся дереву разбора. Описанные выше этапы осуществляются при помощи вызова функций сторонних модулей.\par
Для разработки транслятора на основе измененного и переработанного программного кода плагина kumirCodeGenerator был создан модуль \\ arduinoCodeGenerator. Основные изменения затрагивают сущность Generator, содержащую основной объем операций по обработке данных AST-дерева и наращиванию программного кода по нему на выходном языке. \par
Поскольку в изначальном варианте программный код транслировался в язык виртуальной низкоуровневой машины, был кардинально переработан список команд. Список команд для трансляции с языка программирования КуМир в язык программирования С++ приведен в таблице \hyperref[table-2]{2}.
\newpage
\begin{table}[hp!]
	\centering
	\small
	\caption{Список команд, используемый для трансляции с языка программирования КуМир в язык программирования С++} \label{table-2}
\begin{tabular}{|c|c|}
\hline Название операции & Код операции \\
\hline ForLoop & 0 \\
\hline WhileLoop & 1 \\ 
\hline VAR & 2 \\ 
\hline ARR & 3 \\
\hline FUNC & 4 \\ 
\hline CONST & 5 \\ 
\hline IF & 6 \\ 
\hline ELSE & 7 \\ 
\hline SWITCH & 8 \\ 
\hline CASE & 9 \\ 
\hline INPUT & 10 \\ 
\hline OUTPUT & 11 \\ 
\hline BREAK & 12 \\ 
\hline END\_ARG\_DELIM & 13 \\ 
\hline END\_FUNC\_DELIM & 14 \\ 
\hline END\_ARR\_DELIM & 15 \\ 
\hline STR\_DELIM & 16 \\ 
\hline END\_ST\_DELIM & 17 \\ 
\hline END\_VAR\_DELIM & 18 \\ 
\hline END\_ST\_HEAD\_DELIM & 19 \\ 
\hline RET & 20 \\ 
\hline SUM & 21 \\ 
\hline SUB & 22 \\ 
\hline MUL & 23 \\ 
\hline DIV & 24 \\ 
\hline POW & 25 \\
\hline NEG & 26 \\ 
\hline AND & 27 \\ 
\hline OR  & 28 \\ 
\hline EQ  & 29 \\ 
\hline NEQ & 30 \\ 
\hline LS  & 31 \\ 
\hline GT  & 32 \\ 
\hline LEQ & 33 \\ 
\hline GEQ & 34 \\ 
\hline ASG & 35 \\ 
\hline DCR & 36 \\ 
\hline INC & 37 \\
\hline
	\end{tabular}
\end{table}\par
Были изменены инструкции для трансляции циклов, условий, вызова и объявления функций. Были добавлены инструкции для объявления переменных и констант. Блок операций подвергся минимальным изменениям --- были добавлены инструкции инкремента и декремента и присваивания. \par
Также изменилась основная сущность, используемая при трансляции --- сущность инструкции выходного языка. Были удалены поля для хранения данных о регистре, спецификации строки, спецификации модуля и были добавлены поля для хранения имени операнда и типы операнда, если присутствует.
\paragraph{Трансляция циклов}\par
Существует 4 типа циклов в языке программирования КуМир: стандартный для языков программирования высокого уровня цикл, выполняющийся некоторое количество раз, определяемое набором элементов в указанном диапазоне ``нц для``, цикл с предусловием ``нц пока``, цикл, выполняющийся n раз ``нц для n раз``, а также цикл, выполняющийся постоянно до остановки исполнения ``нц всегда``. При трансляции в низкоуровневый язык, этап трансляции циклов требовал одной инструкции --- ``LOOP``, а также тела операций, выполняющихся до данной метки. В начале транслировалось тело цикла, в случае цикла с предусловием до тела транслировалось условие исполнения, на последнем этапе трансляции добавлялась инструкция ``LOOP``, объявляющую метку завершения определения цикла. \par
Для трансляции циклов в язык С++ были добавлены инструкции для соответствующих типов циклов --- ForLoop, WhileLoop. Циклы `` нц пока``и `` нц всегда`` определяются при помощи инструкции WhileLoop, ``нц для`` и ``нц для n раз`` - при помощи ForLoop. \par
В начале трансляции цикла любого типа указывается заголовок, определяющий тип цикла и возможные предусловия. В случае цикла ``нц пока``, заголовок содержит условие окончания работы, состоящее из ряда выражений.\par
После трансляции заголовка инструкции цикла транслируется тело цикла. Трансляция завершается инструкцией END\_ST\_DELIM.
\paragraph{Трансляция подвыражений}
Трансляция подвыражений осуществляется при помощи метода calculate. Любое подвыражение представляется бинарным деревом, в вершине которого находится операнд, а на листьях - константы или переменные. Для корректной трансляции подвыражений требуется разобрать дерево подвыражения снизу вверх --- найти узел, листья которого не содержат дальнейшей вложенности, затем добавить в стек инструкций левый лист узла, затем сам узел, в конце --- правый лист. Метод calculate используется во множестве мест и содержит логику для трансляции переменных, констант, вызовов функций и подвыражений. Поскольку метод является рекурсивным, невозможно добавить дополнительный блок операций трансляций, описанный выше, в тело метода calculate, поэтому было принято решение вынести логику данного метода в новый - innerCalculation, превратив метод исходный в обертку, куда и была добавлена вспомогательная логика.
\paragraph{Трансляция условных выражений}
Изначально, трансляция условных конструкций состояла из определения количества подвыражений транслируемого выражения и поиска ошибок. На каждую конструкцию ``если  то`` и ``иначе`` добавлялась инструкция безусловного перехода, изменяя ход исполнения программы. Для установки места программы низкоуровнего языка, куда совершался переход используется регистр IP. \par
В разработанной реализации трансляция условных выражений повторяет трансляцию цикла с предусловием за исключением первой инструкции --- вначале, в стек инструкций добавляется инструкция ``IF`` или ``ELSE``, указывающая транслятору на объявление соответствующего блока. Процесс повторяется пока сущность, содержащая данные об условном выражении не опустеет.\par
Трансляция блоков `выбор` происходит следующим образом: вначале в стек заносится инструкция с кодом ``SWITCH``, далее добавляется переменная, значения которой перебираются и на каждый блок `при условие` добавляется инструкция ``CASE`` и константа, хранящая значение переменной. В случае наличия метки ``иначе`` в блоке ``выбор``, добавляется инструкция ``CASE`` без константы, транслирующаяся в инструкцию ``default`` в коде выходного языка.
\paragraph{Трансляция переменных и констант}
В исходной версии при трансляции констант в выражениях или при инициализации, в стек виртуальной машины заносился индекс переменной или константы среди всех встреченных при трансляции, извлекаемый по ссылке на этапе исполнения. В разработанной реализации в случае использования переменной в стек добавляется инструкция ``VAR``, хранящая ссылку на название переменной и на тип, в случае объявления. Трансляция констант начинается с занесения в стек инструкции ``CONST``, хранящей индекс значения и тип константы в случае инициализации.\par

\section{Реализация системы тестирования}
\subsection{Процесс тестирования} 
Под тестированием компилятора понимается сборка транслятора из исходных кодов, трансляция тестовой программы и сравнение результатов работы транслятора с ожидаемым результатом. Было решено автоматизировать процесс тестирования, для повышения качества и снижения сложности процесса. \par
Т.к. язык программирования и среда КуМир - кроссплатформенные проекты, в начале процесса автоматизации стоило решить вопрос с внешними условиями - операционной системой, набором используемых пакетов и библиотек, т.о. первым шагом к автоматизации тестирования явилось создание централизованной среды для сборки компилятора, а именно разработка dockerfile файла, содержащий набор инструкций для сборки транслятора из исходных кодов. В качестве операционной системы была выбрана Ubuntu, ввиду широкой распространенности, большого сообществу разработчиков и активной поддержке пакетов с данной системой в репозитории docker. \par
Далее встал вопрос автоматизации запуска транслятора. Для решения этой проблемы был разработан скрипт на языке Python 3. \par
Для автоматизации запуска тестовой системы в репозитории разрабатываемого транслятора были настроены службы автоматического запуска(Github Actions) при отправке изменений и создании запроса на внесение изменений в целевую ветвь. Исходный код, используемый для инициализации системы тестов приведен в приложении А. \par

\subsection{Тесты}
Для тестирования были разработаны набор тестов, покрывающие основные инструкции языка программирования КуМир, а именно: работа с переменными(инициализация, присваивание), арифметические и логические выражения, ветвления, циклы, а также функции и процедуры. Тестирование построено на принципе сравнения ожидаемого результат с результатом работы транслятора. Тесты сгруппированы по подмножествам инструкций исходного языка.
\image{1}{Группы тестов}
Группа состоит из секций, представляющих отдельные инструкции. Для создания тестовой секции, например, для тестирования трансляции функций, необходимо 2 файла - файл с расширением .kum на исходном языке программирования, а также файл с расширением .exp - файл с предполагаемым результатом работы транслятора, содержащий программу на языке С++.  Пример секции тестов приведен на рисунке 2.
\image{1}{Пример секции тестов}
Под тестом транслятора понимается 2 файла, содержащие 1 или несколько инструкций на исходном и выходном языках программирования. На данный момент разработано чуть больше 200 тестов. 

\subsection{Программа-тестер}
Для автоматизации тестирования было разработано консольное приложение-тестер транслятора. В качестве языка программирования был выбран Python 3. Для работы с программой был разработан ряд аргументов командной строки, а также справка. Список аргументов командной строки приведен ниже:
\begin{Verbatim}[fontsize=\small, numbers=left]
[-h] [--help] - show help.
[-tr] [--translator] ["the path to pre-builded kumir2 to arduino translator
instance"] - show app what translator instance to use.
[-t] [--path-to-tests] ["the path to tests folder"] = show app
  the folder with test files.
[-o] [--output] ["the path to log file"] - show app where to store test logs.
[-d] [--duplicate] - duplicate output to console.
[-ss] [--skip-successfull] - skip open log info about succesfully completed tests.
[-sf] [--skip-failed] - skip open log info about failed tests.
[-swe] [--skip-without-expectation] - skip open log info about
 tests for which the file with expectations was not found.
[-sce] [--skip-with-compiler-error] - skip open log info about
 tests ended with compiler error.
[-b] [--brief] - skip open log info about all tests.
\end{Verbatim}
Было решено разработать программу гибкой и информативной. Для работы необходимы 2 аргумента - –translator(путь к транслятору), а также –path-to-tests(путь к папке с тестами). Исходный код скрипта для тестирования приведен в приложении Б.
По умолчанию результат тестирования записывается в файл, также есть возможность продублировать вывод в консоль. Существует 4 состояния, отражающие результат работы компилятора:
\begin{enumerate}
\item успех;
\item провал;
\item ошибка компиляции;
\item не хватает файла с ожиданиями.
\end{enumerate} \par
Состояния 3 и 4 могут быть получены по причине некорректного содержания тестовых файлов - либо написанная на языке программирования КуМир программа имеет ошибки и не может быть скомпилирована, либо не был найден файл с расширением .exp, содержащий ожидания работы компилятора. В других случаях, текст сообщения с результатами тестирования содержит предложение вызвать команду vimdiff с путями до файлов и прореферировать результат. Можно посмотреть как три файла сразу (исходный код, ожидаемый результат, результат работы компилятора), так и только ожидания и результат работы. Пример сообщения о результатах работы приведен на рисунке 3.
\image{0.5}{Пример сообщения с возможностью подробно посмотреть результаты тестирования}
В начале вывода информации приведена краткая статистика - сколько тестов завершилось и с каким состоянием. Объем вывода можно фильтровать и убирать подробную информацию о сообщениях в состояниях 1-4, либо полностью отключить подробный вывод информации, добавив флаг -b. При дублировании вывода в консоль, в зависимости от состояния, сообщение будет выделено цветом. Пример краткого вывода по результатам тестирования приведен на рисунке 4. 
\image{1}{Пример краткого вывода по окончанию тестирования}
На данный момент, система тестирования демонстрирует следующие результаты:
\begin{enumerate}
\item 3 теста завершились успешно;
\item 23 теста провалились;
\item во время запуска 1 теста произошла ошибка компиляции;
\item во время запуска 1 теста не был найден файл с ожиданиями. 
\end{enumerate}\par
Полученные результаты демонстрируют большой процент неточностей в работе разработанного транслятора. Найденные ошибки в работе необходимо исправить.
\conclusion

В ходе тестирования разработанного транслятора с языка программирования КуМир в язык программирования С++ был выявлен ряд ошибок. Автоматизация процесса тестирования позволяет быстро расширять список тестов и увеличивать процент покрытия, влияющий на надежность и безотказность работы транслятора. Создание тестовых случаев позитивно сказывается на процессе разработки, ведь тестовые сценарии являются документацией. 
Автоматизация запуска программы-тестера при помощи Github Actions позволит быстрее отсеивать некачественный код, влияющий на работоспособность транслятора.
В дальнейшем разработанная система тестов может быть доработана при помощи методов Fuzzing-тестирования и автоматизированной генерации тестовых файлов. 
Исходный код разработанной программы тестера и транслятора можно найти в открытом репозитории [7].

В рамках ВКР был был разработан транслятор с языка программирования КуМир в язык С++. Программа имеет ряд недостатков, которые предстоить исправить и список улучшений, которые планируется реализовать. Среди задач по улучшению транслятора можно выделить следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item создание отдельного клиента среды программирования КуМир, специально для разработки роботов;
\item добавление возможности прошивки робота из клиента;
\item добавление инструмента выбора порта с подключенным роботом для прошивки;
\item {добавление настраиваемого алгоритма прошивки, определяющего роль результата трансляции в архитектуре программы для прошивки робота.}
\end{itemize}\par
После реализации клиента среды программирования КуМир для разработки роботов и исправления ошибок транслятора найденных в ходе тестирования планируется спроектировать и разработать робота на базе аппаратного комплекса Arduino для опробации разработки в школах. \par
\begin{thebibliography}{99}
\bibitem{Ione} Статья о КуМире на электронном образовательном портале Фоксфорд [Электронный ресурс] URL: $https://foxford.ru/wiki/informatika/$
sredaprogrammirovaniya-kumir
\bibitem{Ione} Статья о предназначении комплектов Arduino [Электронный ресурс] URL: $http://arduino.ru/$
\bibitem{Ione} Максименков Д.А., Рогов Р.Ю. Применение метода инструментирования тестовых
программ при отладке оптимизирующих компиляторов. Вопросы
радиоэлектроники, 2010, вып. 3, стр. 50-61
\bibitem{Ione} IBM. IBM Rational Functional Tester // IBM.
\bibitem{Ione} IBM. IBM Rational Test Workbench // IBM.
\bibitem{Ione} SmartBear. TestComplete Platform // SmartBear.
\bibitem{Ione} Репозиторий с исходным кодом транслятора [Электронный ресурс] URL:$https://github.com/CaMoCBaJL/kumir2/tree/translator_tests$
\bibitem{Ione} Cистема программирования Кумир 2.x А.Г.Кушниренко , М. А. Ройтберг , Д.В.Хачко, В. В. Яковлев [Электронный ресурс] URL:$http://roytberg.lpm.org.ru/pdfs/kumir2x_2015.pdf$
\bibitem{Ione} Леонов А.Г., Кушниренко А.Г. Методика преподавания основ алгоритмизации на базе системы «КуМир». М.: «Первое сентября», 2009.
\bibitem{Ione} Кушниренко А.Г., Рогожкина И.Б., Леонов А.Г. // Большой московский семинар по методике раннего обуч. информатике (ИТО-РОИ-2012): сб. докл. ПиктоМир: пропедевтика алгоритмического языка (опыт обучения программированию старших дошкольников). М.: Конгресс конференций ИТО-РОИ, 2012.
\end{thebibliography}

%\bibliographystyle{gost780uv}

%\bibliography{refs}
\appendix
\section{Исходный код dockerfile, унифицирующий настройки среды запуска системы тестирования}
\begin{Verbatim}[fontsize=\small, numbers=left]
FROM ubuntu

ARG path_to_tests_folder="./Tests"

LABEL EMAIL=gorka19800@gmail.com

#install all the necessary libs and apps
RUN apt-get update
RUN apt-get dist-upgrade -y
RUN echo "8"| apt-get install -y qttools5-dev-tools
RUN apt-get install -y git python3 cmake qtbase5-dev g++ libqt5svg5-dev
 libqt5x11extras5-dev qtscript5-dev libboost-system-dev zlib1g zlib1g-dev
#setup git
RUN git config --global user.email "gorka19800@gmail.com"
RUN git config --global user.name "Test suit"
#clone repo and prepare for building kumir-to-arduino translator
RUN mkdir /home/Sources
WORKDIR /home/Sources/
RUN git clone https://github.com/CaMoCBaJL/kumir2
WORKDIR kumir2/
RUN git pull
RUN git checkout translator_tests
RUN git merge -s ours --no-edit origin/ArduinoFixes
RUN mkdir build
WORKDIR build/
#build translator
RUN cmake -DUSE_QT=5 -DCMAKE_BUILD_TYPE=Release ..
RUN make -j 18
#start tests
WORKDIR ../kumir_tests/
RUN touch test_results.log
RUN python3 test_script.py -d -o ./test_results.log
-tr ../build/bin/kumir2-arduino -t \$path_to_tests_folder
\end{Verbatim}
\section{Исходный код скрипта, производящего тестирование транслятора}
\begin{Verbatim}[fontsize=\small, numbers=left]
import os
import sys
import subprocess

#constants
class CONSOLE_BG_COLORS:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class TEST_RESULT_STATE:
    COMPLETED = 1
    MISSING_EXPECTATION = 2
    COMPILER_ERROR_HAPPEND = 3
    FAILED = -1
    NONE = 0

COMPILER_ERROR_LABEL = "ERROR!"

EXPECTATION_FILE_EXTENTION = ".exp"
SOURCE_FILE_EXTENTION = ".kum"

CONTROL_CHARACTERS = ["\n", "\r", "\t", " "]
BYTES_TO_READ_COUNT = 1024
CHAR_THRESHOLD = 0.3
TEXT_CHARACTERS = ''.join(
    [chr(code) for code in range(32, 127)] +
    list('\b\f\n\r\t')
)
BINARY_CHAR_EXAMPLE = '\x00'

TESTS_FOLDER_NAME = "Tests"

ARGS = {"help": ["-h", "--help"],
        "translator": ["-tr", "--translator"],
        "output": ["-o", "--output"],
        "duplicate": ["-d", "--duplicate"],
        "skip-successfull": ["-ss", "--skip-successfull"],
        "skip-failed": ["-sf", "--skip-failed"],
        "skip-without-expectation": ["-swe", "--skip-without-expectation"],
        "skip-with-compiler-error": ["-sce", "--skip-with-compiler-error"],
        "brief": ["-b", "--brief"],
        "path-to-tests": ["-t", "path-to-tests"]
        }

ERRORS = {
    "wrong input": "Wrong args input - you should type path to file after -c or
     -o flags!",
    "file not exist": "File doesn't exist!",
    "wrong file extention": "File extention for translator is not correct! It should
     be a bin-file.",
    "no path to tests": "Wrong args input - you should type path to tests folder
     after -t flag!"
}

#data structure to store test results
class TestResult:

    __text_color = CONSOLE_BG_COLORS.OKGREEN
    __header_text = ""
    SKIPPED_TEST_TYPES = [TEST_RESULT_STATE.NONE]

    def __init__(self, name: str, source: str, expectation: str, result: str):
        self.name = name
        self.source_file_name = source
        self.expectation_file_name = expectation
        self.resultFileName = result
        self.state = TEST_RESULT_STATE.NONE

    def __str__(self):
        self.__setup_output()
        additional_test_data = f'''
        Test group expectations: {self.expectation_file_name}
        Test group results: {self.resultFileName}. 
        To get more detail info about comparison results, print:
        vimdiff {self.source_file_name} {self.expectation_file_name}
         {self.resultFileName}
        or vimdiff {self.expectation_file_name} {self.resultFileName}
        {CONSOLE_BG_COLORS.ENDC}
        '''
        return f'''{self.__text_color}
        Test {self.name}.
        {self.__header_text}
        Sources for the test: {self.source_file_name}
        {additional_test_data if self.state is TEST_RESULT_STATE.COMPLETED
         or self.state is TEST_RESULT_STATE.FAILED else ""}
        '''

    def __setup_output(self):
        if self.state == TEST_RESULT_STATE.COMPLETED:
            self.__text_color = CONSOLE_BG_COLORS.OKGREEN
            self.__header_text = "Congratulations! Test completed successfully!"
        elif self.state == TEST_RESULT_STATE.MISSING_EXPECTATION:
            self.__text_color = CONSOLE_BG_COLORS.OKCYAN
            self.__header_text = "Oh! Test didn't complete: no expectation"
        elif self.state == TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND:
            self.__text_color = CONSOLE_BG_COLORS.WARNING
            self.__header_text = "Oh! Test didn't complete: compiler error"
        elif self.state == TEST_RESULT_STATE.FAILED:
            self.__text_color = CONSOLE_BG_COLORS.FAIL
            self.__header_text = "Sorry, but test failed..."

class TestSection:

    def __init__(self, section_name) -> None:
        self.name = section_name
        self.test_results = []
    
    def __str__(self) -> str:
        columns, _ = os.get_terminal_size()
        if (len(self.test_results) > 0):
            return f"""
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            Test section {self.name} starts here:
            {os.linesep.join(list(map(lambda test_result: str(test_result),
             self.test_results)))}
            End of {self.name} section tests
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            """
        
        return ''

#functions
def remove_control_characters(data_array):
    result = []
    for i in data_array:
        for cc in CONTROL_CHARACTERS:
            i = i.replace(cc, "")

        if i:
            result.append(i)

    return result

def get_file_data(filename):
    if not os.path.exists(filename):
        return ''
    file = open(filename, "r")
    result = file.readlines()
    file.close()
    return result

def has_errors(text):
    return COMPILER_ERROR_LABEL in text

def process_sources(source_filename, path_to_translator):
    path, _ = os.path.splitext(source_filename)
    result_filename = path + ".kumir.c"

    #call kumir2-arduino with params: 
    --out="path_to_cwd/results/test_name.kumir.c" -s ./test_name.kum
    popen = subprocess.Popen([path_to_translator,
                              f'--out={result_filename}',
                              '-s',
                              source_filename],
                             stdout=subprocess.PIPE)
    popen.wait()
    popen.stdout.read()

    return result_filename

def compare_data(expected_data, processed_data) -> TEST_RESULT_STATE:
    result_without_kumir_ref = remove_control_characters(processed_data[2:])
    expected_data = remove_control_characters(expected_data)

    if (has_errors(result_without_kumir_ref)):
        return TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND

    for i in range(len(result_without_kumir_ref)):
        if result_without_kumir_ref[i] != expected_data[i]:
            return TEST_RESULT_STATE.FAILED

    return TEST_RESULT_STATE.COMPLETED

def get_test_result_type_counters(test_sections):
    counters = {
        TEST_RESULT_STATE.COMPLETED: 0,
        TEST_RESULT_STATE.FAILED: 0,
        TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND: 0,
        TEST_RESULT_STATE.MISSING_EXPECTATION: 0,
    }

    for test_section in test_sections:
        for test_result in test_section.test_results:
            counters[test_result.state] += 1


    return counters

#log comparison results to file
def log_test_results(logs_filename, data_to_log: TestSection, log_to_console):
    result_type_counters = get_test_result_type_counters(data_to_log)
    completed_tests_count, failed_tests_count,
     compiler_error_happend_tests_count, 
     missing_expectations_tests_count = \
    [result_type_counters[k] for k in result_type_counters]

    log_data = []
    for test_section in data_to_log:
        test_section.test_results = list(filter
        (lambda test_result: test_result.state not in 
        TestResult.SKIPPED_TEST_TYPES, test_section.test_results))
        log_data.append(test_section)

    log_data_strings = list(map(lambda x: str(x), log_data))
    log_data_strings.insert(0, f'''
    There were found: {len(log_data)} tests.
    {CONSOLE_BG_COLORS.OKGREEN} Completed: 
    {completed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.FAIL} Failed: 
    {failed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.WARNING} With compiler error happend:
     {compiler_error_happend_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.OKCYAN} Missed expectation file: 
    {missing_expectations_tests_count} {CONSOLE_BG_COLORS.ENDC}''')

    if not os.path.exists(logs_filename):
        open(logs_filename, "a").close()

    log_file = open(logs_filename, "a")
    log_file.writelines(log_data_strings)
    log_file.close()

    if log_to_console:
        print(f"{os.linesep}".join(log_data_strings))

def is_binary_file(filename):
    file_stream = open(filename, 'rb')
    file_content = file_stream.read(BYTES_TO_READ_COUNT)
    file_stream.close()
    
    if not len(file_content):
        #file is empty, nothing to read
        return False
    
    if ord(BINARY_CHAR_EXAMPLE) in file_content:
        #file contains binary symbols
        return True
    
    binary_chars = file_content.translate(TEXT_CHARACTERS)
    return float(len(binary_chars)) / len(file_content) > CHAR_THRESHOLD

def validate_file_name(filename: str, is_log_file: bool):   
    if not os.path.exists(filename):
        print(filename + ERRORS.get("file not exist"))
        sys.exit(2)
    if not os.path.isfile(filename):
        print(ERRORS.get("wrong input"))
        sys.exit(2)
    if not is_log_file and not is_binary_file(filename):
        print(ERRORS.get("wrong file extention"))
        sys.exit(2)
        
def show_help():
    print(""" kumir2-arduino tester.
    Description:
    Approach of this app is to debug the work of kumir2 
    to arduino translator. It uses compiled translator's 
    instance, pre-builded locally on PC.
    To start the work you should input path to compiler 
    and path to logs file.
    Flags:
    [-h] [--help] - show help.
    
    [-tr] [--translator] ["the path to pre-builded kumir2 
    to arduino translator instance"] - show app what 
    translator instance to use.
    
    [-t] [--path-to-tests] ["the path to tests folder"] = 
    show app  the folder with test files.
    
    [-o] [--output] ["the path to log file"] - show app 
    where to store test logs.
    
    [-d] [--duplicate] - duplicate output to console.

    [-ss] [--skip-successfull] - skip open log info about 
    succesfully completed tests.

    [-sf] [--skip-failed] - skip open log info about failed tests.

    [-swe] [--skip-without-expectation] - skip open log info 
    about tests for which the file with expectations 
    was not found.

    [-sce] [--skip-with-compiler-error] - skip open log info 
    about tests ended with compiler error.

    [-b] [--brief] - skip open log info about all tests.
    """)

def process_args():
    result = ["", "", False, ""]
    if ARGS["help"][0] in sys.argv or ARGS["help"][1] 
    in sys.argv:
        show_help()
        sys.exit(2)

    if ARGS["skip-successfull"][0] in sys.argv or ARGS["
    skip-successfull"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.COMPLETED)
    
    if ARGS["skip-without-expectation"][0] in sys.argv 
    or ARGS["skip-without-expectation"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT_STATE
        .MISSING_EXPECTATION)

    if ARGS["skip-with-compiler-error"][0] in sys.argv or
     ARGS["skip-with-compiler-error"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT
        _STATE.COMPILER_ERROR_HAPPEND)

    if ARGS["skip-failed"][0] in sys.argv or ARGS[
    "skip-failed"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.FAILED)

    if ARGS["brief"][0] in sys.argv or ARGS["brief"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES = [
            TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND, 
            TEST_RESULT_STATE.COMPLETED, 
            TEST_RESULT_STATE.FAILED,
            TEST_RESULT_STATE.MISSING_EXPECTATION
            ]

    args = sys.argv[1:]
    for i in range(1, len(args)):
        if args[i - 1] in ARGS["translator"] or args[i - 1]
         in ARGS["output"] or args[i - 1] in ARGS
         ["path-to-tests"]:
            if (os.path.isfile(args[i])):
                validate_file_name(args[i], False if args[i - 1]
                 in ARGS["translator"] else True)

            if args[i - 1] in ARGS["translator"]:
                result[0] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["output"]: 
                result[1] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["path-to-tests"]:
                result[3] = os.path.abspath(args[i])
        elif args[i-1] in ARGS["duplicate"]:              
            result[2] = True
            
    return result

def get_files_with_absolute_paths(folder_name):
    path_to_folder = os.path.join(os.getcwd(), folder_name)
    files = 
    list(map(lambda x: os.path.join(path_to_folder, x),
     os.listdir(path=path_to_folder)))
    files.sort()

    return files

def get_source_and_expectation(dir_files):
    sources = []
    expectations = []
    for file in dir_files:
        if (os.path.isfile(file)):
            ext = os.path.splitext(file)[1]
            if (ext == EXPECTATION_FILE_EXTENTION):
                expectations.append(file)
            elif (ext == SOURCE_FILE_EXTENTION):
                sources.append(file)
    
    return [sources, expectations]

def get_folder_contents_full_paths(path_to_folder):
    return list(
        map(
            lambda x: os.path.join(os.sep, path_to_folder, x),
            os.listdir(path_to_folder)
            )
        )

def calculate_test_sections(path_to_tests_folder):
    result = []
    test_folder_paths = get_folder_contents_full
    _paths(path_to_tests_folder)
    for test_folder_path in test_folder_paths:
        if os.path.isfile(test_folder_path):
            continue

        result.append(TestSection(test_folder_path.
        split(os.sep)[-1]))
        test_paths = get_folder_contents_full_paths
        (test_folder_path)
        for test_dir_path in test_paths:
            source_files, expectation_files =
          get_source_and_expectation(get_folder_contents_full_paths
            (test_dir_path))
            if os.path.isfile(test_dir_path) or len
            (expectation_files) > 1 or len(source_files)
             < 1:
                continue
            
            result[-1].test_results.append(TestResult(
                test_dir_path.split(os.sep)[-1],
                source_files[0],
                "", ""
                )
            )

            if len(expectation_files) == 1:
                result[-1].test_results[-1]
         .expectation_file_name  = expectation_files[0]
                result[-1].test_results[-1].resultFileName
                 = process_sources(source_files[0],
                  args_data[0])
                result_data = get_file_data(result[-1]
               
                .test_results[-1].resultFileName)
                expected_data =
     get_file_data(result[-1].test_results[-1].expectation_file_name)
                result[-1].test_results[-1].state 
                = compare_data(expected_data, result_data)
            else: 
                result[-1].test_results[-1].state = 
                TEST_RESULT_STATE.MISSING_EXPECTATION

    return result

if __name__=="__main__":
    args_data = process_args()

    if not args_data[3]:
        print("Didn't find any test to execute. Shutting down.")       
        sys.exit()

    test_results = calculate_test_sections(args_data[3])

    log_test_results(args_data[1], test_results, args_data[2])
\end{Verbatim}
\end{document}