\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}

\usepackage{graphicx}
\usepackage{xcolor}

\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{cmap}
\renewcommand{\rmdefault}{cmr} % Шрифт с засечками
\renewcommand{\sfdefault}{cmss} % Шрифт без засечек
\renewcommand{\ttdefault}{cmtt} % Моноширинный шрифт
\usepackage{tempora}
\usepackage{cite}
\usepackage{multirow}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\definecolor{linkcolor}{HTML}{FF4500}
\hypersetup{pdfstartview=FitH, linkcolor=linkcolor, urlcolor=linkcolor, colorlinks=true}

\addto\captionsrussian{\def\refname{ }}
\linespread{1.6}
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}
\renewcommand*\thesection{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\number\numexpr\value{subsection}\relax}

% ----------------------------------------------------------------
% elResourceRef command
% usage: 
% \elResourceRef{<resource name>}{<url to resource>}{date of the application}
\newcommand{\elResourceRef}[3]{#1 [Электронный ресурс] URL: #2 (дата обращения: #3)}
% ----------------------------------------------------------------
% image command
% usage: 
%\image{<image scale>}{<description text>}
\newcommand{\image}[2]{%
	\begin{center}%
	\label{img\arabic{imgCounter}}%
	\includegraphics[scale = #1]{\arabic{imgCounter}.png}\par%
	Рисунок \arabic{imgCounter} --- #2%
	\addtocounter{imgCounter}{1}%
	\end{center}%
}
%-----------------------------------------------------------------
% addBibItem command
% usage:
% \addBibItem{<\elResourceRef{<resource name>}{<url to resource>}{date of the application}>};
% \addBibItem{<custom item name>}
\newcommand{\addBibItem}[1]{%
\bibitem{Ione}#1%
\label{\arabic{labelCounter}}%
\addtocounter{labelCounter}{1}%
}
%-----------------------------------------------------------------
% sourceRef command
% usage:
% \noLabelSourceRef
\newcommand{\noLabelSourceRef}{{[\textcolor{green}{\hyperref[\arabic{hyrefCounter}]{\arabic{hyrefCounter}}\addtocounter{hyrefCounter}{1}}]}}
%-----------------------------------------------------------------
%custom counters declaration
\newcounter{imgCounter}
\setcounter{imgCounter}{1}
\newcounter{labelCounter}
\setcounter{labelCounter}{1}
\newcounter{hyrefCounter}
\setcounter{hyrefCounter}{1}
%------------------------------------------------------------------

\newtheorem{lem}{Лемма}

\begin{document}
\lstset{basicstyle = \small}
% Кафедра (в родительном падеже)
\chair{Кафедра информатики и программирования}

% Тема работы
\title{Разработка системы программирования ``КуМир роботы``}

% Курс
\course{2}
\group{273}

% Факультет (в родительном падеже)
\department{КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.04 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Пронина Антона Алексеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{М.\,В.\,Огнева}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{старший преподаватель} %должность, степень, звание
\saname{Е.\,Е.\,Лапшева}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{3}
\course{2}
% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{производственная распределенная (научно-исследовательская работа)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{18}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.09.2023}
\practFinish{15.01.2024}


% Наименование практики (только для практики, для остальных
% типов работ не используется)


% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)


% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)


% Год выполнения отчета
\date{2024}

\maketitle
% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering
\tableofcontents


\intro


Одним из наиболее интересных вопросов, требующих особого внимания в обучении информатике, является вопрос системы обучения программированию. Это связано с тем, что профессия специалистов в области информатики и информационных технологий в какой-то мере начинается со школы. Одним из прямых приложений программирования является робототехника. \par
Ввиду растущего интереса в сфере образования к обучению робототехнике в школе и широкой распространенности и глубокой степени интеграции современной образовательной системы с этим языком, появилась идея о разработке транслятора с языка КуМир в язык C++. Актуальность идеи заключается в снижении входного порога в область робототехники как со стороны ученика, предоставляя возможность, используя полученные навыки программирования в системе КуМир, заниматься разработкой роботов, так и со стороны преподавателя, уменьшая затраты на приобретение программных и аппаратных средств разработки. В качестве аппаратной платформы данной задачи был выбран электронный конструктор и удобная платформа быстрой разработки электронных устройств для новичков и профессионалов - платы Arduino, ввиду низкой стоимости устройств, периферийных модулей, простоты разработки аппаратных устройств на базе этих плат, высокой модульности систем и их высокой распространенности среди робототехников. \par
Транслятор с языка КуМир в язык C++ стал отправной точкой процесса создания комплекса аппаратно-программных  и методических средств изучения робототехники в школе с использованием языка программирования КуМир. Важным аспектом комплекса является доступность и удобство изучения робототехники. Для повышения доступности изучения, было принято решение разработать отдельный клиент системы программирования КуМир “КуМир Роботы”, направленный на изучение робототехники на основе плат Arduino. \par
Цель работы - разработка  системы программирования роботов на основе плат Arduino на базе исходных кодов системы программирования КуМир.
Для выполнения поставленной цели, требуется выполнить следующие задачи:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item проанализировать исходные коды системы программирования КуМир;
\item проанализировать историю развития технологий, используемых для разработки системы программирования;
\item доработка и устранение ошибок в исходном коде системы программирования КуМир;
\item проанализировать системы программирования плат Arduino и их аналоги;
\item разработать отдельный клиент для разработки роботов;
\item обновить используемые библиотеки и фреймворки для разработки среды программирования;
\item разработать плагин для взаимодействия с платами Arduino.
\end{itemize}
\section{Предметная область. Подходы, понятия, средства}
\subsection{Среда исполнения и язык программирования КуМир}
КуМир (Комплект Учебных МИРов) - система программирования, предназначенная для поддержки начальных курсов информатики и программирования в средней и высшей школе с открытым исходным кодом \noLabelSourceRef. Спектр возможностей применения данной системы программирования ограничен, ряд стандартных команд позволяет разрабатывать небольшие приложения с целью изучения основ программирования на процедурных языках. \par
На данный момент язык КуМир - это язык, с которого хорошо начать, чтобы освоить основы алгоритмического подхода и процедурный стиль программирования. Система КуМир \noLabelSourceRef в современном ее состоянии (с подсистемой ПиктоМир) состоит из расширяемого набора исполнителей (или роботов), набора систем программирования и вспомогательных утилит и программ. Расширяемый набор исполнителей (роботов) представляет собой отдельные самостоятельные программы и (или) электронно-механические устройства, имеющие собственное пультовое управление (интерфейс), а также возможность локального или сетевого управления из выполняющей системы. Набор систем программирования:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item система программирования КуМир на школьном алгоритмическом языке, состоящая из редактора-компилятора алгоритмического языка с многооконным интерфейсом, интегрированная с выполняющей системой. Система не является полноценным интерпретатором или компилятором школьного алгоритмического языка. Зачастую, программа на школьном алгоритмическом языке компилируется в некий промежуточный код (подобный подход был использован в языке Java), который затем интерпретируется и исполняется с автоматической генерацией точек останова по событиям и шагам (при пошаговом выполнении). В системе программирования КуМир также отсутствует отладчик в его классическом понимании. Это имеет свои причины, так как сильно упрощает процесс освоения и написания системы программирования КуМир, а также отладку программ. Все изменения используемых в школьной программе величин автоматически визуализируются на полях программы. Визуализируются и результаты логических операций. Кроме того, к системе можно подключать любого исполнителя (робота) из набора и программно управлять им;
\item система бестекстового, пиктографического программирования ПиктоМир. В ней учащийся собирает программу из команд исполнителя (робота). Управляющие конструкции языка представлены определенной параметрической организацией алгоритмов. Созданная учащимися программа при выполнении передает команды робота и получает его состояние; 
\item система программирования на производственном языке программирования С++, Python и т.п \noLabelSourceRef; 
\end{itemize}
\subsection{Архитектура системы программирования КуМир}
Помимо инструментов разработки, среда обладает рядом функциональных возможностей - просмотр документации, создание и выполнение практикумов, работа с окном в свернутом режиме и пр. Стартовое окно системы программирования КуМир представлено на рисунке 1.
\image{0.7}{Внешний вид среды программирования КуМир}
С точки зрения кода, система программирования КуМир представляет собой монолитное приложение. Исходные коды разделены на 2 основные части:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item библиотеки;
\item плагины.
\end{itemize}
Существует ряд клиентов среды программирования КуМир - для учителя, для ученика старших классов, стандартный клиент. Помимо клиентов, существуют отдельные приложения для компиляции и исполнения кода на языке программирования КуМир. Описанные выше приложения создаются при помощи разделяемого программного кода и вспомогательных инструментов. \par
К вспомогательным инструментам стоит отнести и ряд функций, упрощающих работу с системой сборки CMake \noLabelSourceRef. В исходных кодах можно найти функции упрощающие поиск библиотек для фреймворка QT, определения и установки файлов ресурсов при сборке, а также функции для сборки артефактов приложения(клиентов) из исходных кодов. \par
Для создания нового артефакта - клиента или приложения командной строки используется CMake-функция $kumir2\_add\_launcher$. По созданному конфигурационному файлу CmakeLists.txt с описанием нового клиента по аналогии с имеющимися, во время сборки приложения, программа-сборщик обнаружит файл конфигурации и с его помощью создаст клиент. Пример конфигурационного файла CmakeLists.txt приведен в листинге 1:
\begin{Verbatim}[fontsize=\small, numbers=left]
project(kumir2-robots)
cmake_minimum_required(VERSION 3.0)

find_package(Kumir2 REQUIRED)

kumir2_add_launcher(
   NAME            kumir2-robots
   SPLASHSCREEN    "splashscreen-classic.png"
  WINDOW_ICON     "window-icon-classic.png"
    APP_ICON_NAME   "kumir2-classic"
   X_ICONS_DIR     "../../../app_icons/linux/hicolor"
    WIN_ICONS_DIR   "../../../app_icons/win32"
   X_NAME          "Kumir Robots Edition"
    X_NAME_ru       "Кумир для роботов"
    X_CATEGORIES    "Education,X-KDE-Edu-Misc"
    CONFIGURATION   
  "CourseManager,Editor,ActorArduino, 
 ArduinoCodeGenerator\(preload=Files\), 
 KumirAnalizer\(preload=Files\),*CodeGenerator, 
 KumirCodeRun(nobreakpoints),!CoreGUI\(nosessions\)")
\end{Verbatim}
\begin{center}
Листинг 1 --- Пример содержимого файла CMakeLists.txt для нового клиента системы программирования КуМир
\end{center}
Функция $kumir2\_add\_launcher$ позволяет декларативно настроить результат сборки - указать его название, иконку, а также ряд зависимостей для сборки приложения.\par
Клиент среды программирования состоит из плагинов и исполнителей. Плагины ссылаются на библиотеки КуМир-а, предоставляя конкретные реализации на основе контрактов \noLabelSourceRef, описываемых моделями библиотек.  
Среди инструментов разработчика существуют скрипты для кодогенерации оснастки исполнителей, развертывания приложения в разных операционных системах и генерации CMake-скриптов.
Библиотеки представляют собой набор базовых сущностей, реализующих определенную часть функционала. В подавляющем большинстве, классы, описывающие область знания не содержат в себе логики работы с данной областью и представляют лишь анемичные модели \noLabelSourceRef, \noLabelSourceRef для хранения состояния. Для работы с моделями используются генераторы или фабрики. Среди библиотек существует собственная реализация AST-дерева \noLabelSourceRef. Библиотека содержит модели, описывающие выражения, типы, модули, алгоритмы, переменные и лексемы. Программный код, использующий данные модели представляет собой плагины для кодогенерации.

\conclusion

В ходе тестирования разработанного транслятора с языка программирования КуМир в язык программирования С++ был выявлен ряд ошибок. Автоматизация процесса тестирования позволяет быстро расширять список тестов и увеличивать процент покрытия, влияющий на надежность и безотказность работы транслятора. Создание тестовых случаев позитивно сказывается на процессе разработки, ведь тестовые сценарии являются документацией. 
Автоматизация запуска программы-тестера при помощи Github Actions позволит быстрее отсеивать некачественный код, влияющий на работоспособность транслятора.
В дальнейшем разработанная система тестов может быть доработана при помощи методов Fuzzing-тестирования и автоматизированной генерации тестовых файлов. 
Исходный код разработанной программы тестера и транслятора можно найти в открытом репозитории [7].

В рамках ВКР был был разработан транслятор с языка программирования КуМир в язык С++. Программа имеет ряд недостатков, которые предстоить исправить и список улучшений, которые планируется реализовать. Среди задач по улучшению транслятора можно выделить следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item создание отдельного клиента среды программирования КуМир, специально для разработки роботов;
\item добавление возможности прошивки робота из клиента;
\item добавление инструмента выбора порта с подключенным роботом для прошивки;
\item {добавление настраиваемого алгоритма прошивки, определяющего роль результата трансляции в архитектуре программы для прошивки робота.}
\end{itemize}\par
После реализации клиента среды программирования КуМир для разработки роботов и исправления ошибок транслятора найденных в ходе тестирования планируется спроектировать и разработать робота на базе аппаратного комплекса Arduino для опробации разработки в школах. \par
\begin{thebibliography}{99}
\bibitem{Ione} Оффициальный сайт КуМир [Электронный ресурс]. — 2022. — URL: \url{https://www.niisi.ru/kumir/.} Загл. с экр. Яз. рус.
\bibitem{Ione} Леонов, А. Г. Методика преподавания основ алгоритмизации на базе системы «КуМир» [Электронный ресурс]. — 2009. — URL:  \url{https://inf.1sept.ru/view\_article.php?ID=200901701.} Загл. с экр. Яз. рус.
\bibitem{Ione} Кушниренко, А. Г. докл. ПиктоМир: пропедевтика алгоритмического языка (опыт обучения программированию старших дошкольников) // Большой московский семинар по методике раннего обуч. информатике. — M.: ИТО-РОИ, 2012.
\bibitem{Ione} Манаев Р.Г. ТЕХНОЛОГИЯ ВНЕДРЕНИЯ НЕПРЕРЫВНОЙ ИНТЕГРАЦИИ В КРУПНЫХ ВЫСОКОНАГРУЖЕННЫХ СИСТЕМАХ С МИНИМИЗАЦИЕЙ ОШИБОК И ВРЕМЕННЫХ ПОТЕРЬ СО СТОРОНЫ РАЗРАБОТЧИКОВ // Инновации и инвестиции. 2020. №12.
\bibitem{Ione} Маклафлин Б., Поллайс Г., Уэст Д. Объектно-ориентированнный анализ и проектирование. - СПб.: Питер, 2013. - 608с.: ил.
\bibitem{Ione} Фаулер, Мартин. Шаблоны корпоративных приложений. : Пер. с англ. - М. : ООО “И.Д. Вильямс”, 2016. - 544с.: ил. - Парал. тит. англ. 
\bibitem{Ione} Эванс, Эрик. Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем.: Пер. с англ. - СПб.: ООО “Диалектика”, 2020 - 448с.: ил. - Парал. тит. англ.
\bibitem{Ione} Ахо, Альфред В., лам, Моника С., Сети, Рави, Ульман, Джеффри Д. Компиляторы: принципы, технологии и инструментарий. 2-е изд.: Пер. с англ. - М.: ООО “И.Д. Вильямс”, 2018 - 1184с.: ил. - Парал. тит. англ.
\bibitem{Ione} Пронин А.А., Синельников Е.А. Модули в языке программирования КуМир 2.0 // Информационные технологии в образовании: сборник / редакционная коллегия: С. Г. Григорьев [и др.]. – Саратов: Саратовский университет [издание], 2022. – Вып. 5: материалы XIV Всероссийской научно-практической конференции «Информационные технологии в образовании» (ИТО-Саратов-2022), Саратов, 28-29 октября 2022 г. – 290 с. : ил. (9,19Мб). – URL: https://sgu.ru/node/197426. – Режим доступа: Свободный. Продолжающиеся издания СГУ на сайте www.sgu.ru. [207-211]
\bibitem{Ione} Смирнов Максим докл. Модернизация унаследованных приложений // конференция ArchDays 2023
\bibitem{Ione} Исходный код среды исполнения КуМир [Электронный ресурс]. — URL: \url{https://github.com/a-a-maly/kumir2} Загл. с экр. Яз. рус
\bibitem{Ione} Кушниренко, А. Г. Опыт интеграции цифровой образовательной среды КуМир в платформу Мирера // Объединенная конференция "СПО: от обучения до разработки": материалы конференции / Под ред. В. Л. Чёрный. — МАКС Пресс, 2022. — С. 24–30.
\bibitem{Ione} Список версий фреймворка QT [Электронный ресурс]. — URL: \url{https://wiki.qt.io/Portal:Quick\_Access}
\bibitem{Ione} Вареница Виталий Викторович, Марков Алексей Сергеевич, Савченко Владислав Вадимович, Цирлов Валентин Леонидович ПРАКТИЧЕСКИЕ АСПЕКТЫ ВЫЯВЛЕНИЯ УЯЗВИМОСТЕЙ ПРИ ПРОВЕДЕНИИ СЕРТИФИКАЦИОННЫХ ИСПЫТАНИЙ ПРОГРАММНЫХ СРЕДСТВ ЗАЩИТЫ ИНФОРМАЦИИ // Вопросы кибербезопасности. 2021. №5 (45).
\bibitem{Ione} Амини Камран. Экстремальный Cи. Параллелизм, ООП и продвинутые возможности. — СПб.: Питер, 2021. — 752 с.: ил. — (Серия «Для профессионалов»).
\bibitem{Ione} Бобков В.А., Черкашин А.С. Обработка и визуализация пространственных данных на гибридном вычислительном кластере // Прикладная информатика. 2014. №4 (52).
\bibitem{Ione} Шабалин, К. В. Формирование креативных способностей школьников при выполнении проектов на базе платформы Arduino / К. В. Шабалин // Педагогическое образование в России. — 2022. — No 2. — С. 135–140.
\bibitem{Ione} Глазов Сергей Юрьевич, Сергеев Алексей Николаевич, Усольцев Вадим Леонидович ВОЗМОЖНОСТИ ПРИМЕНЕНИЯ ПЛАТФОРМЫ АRDUINO В УЧЕБНОМ ПРОЦЕССЕ ПЕДАГОГИЧЕСКОГО ВУЗА И ОБЩЕОБРАЗОВАТЕЛЬНЫХ ШКОЛ // Известия ВГПУ. 2021. №10 (163). 
\bibitem{Ione} Серёгин, М. С. Использование платформы Arduino в образовательной деятельности / М. С. Серёгин // Инновационная наука. — 2019. — No 6. —С. 62–64.
\bibitem{Ione} Серёгин, М. С. Использование платформы Arduino в образовательной деятельности / М. С. Серёгин // Инновационная наука. — 2019. — No 6. —
С. 62–64.
\bibitem{Ione} Исходный код приложения Arduino IDE первой версии [Электронный ресурс]. — URL: \url{https://github.com/arduino/Arduino}
\bibitem{Ione} Исходный код приложения Arduino IDE современной версии [Электронный ресурс]. — URL: \url{https://github.com/arduino/arduino-ide}
\bibitem{Ione} Борис Черный. Профессиональный TypeScript. Разработка масштабируемых JavaScript-приложений. - СПб.: Питер, 2021. - 352 с.: ил. - (Серия “Бестселлеры O’Reily”)
\bibitem{Ione} Мардан Азат. React быстро. Веб-приложения на React, JSX, Redux и GraphQL. — СПб.: Питер, 2019. — 560 с.: ил. — (Серия «Библиотека программиста»). 
\bibitem{Ione} Исходный код приложения Arduino CLI [Электронный ресурс]. — URL: \url{https://github.com/arduino/arduino-cli}
\bibitem{Ione} Документация к приложению Arduino CLI [Электронный ресурс]. — URL: \url{https://arduino.github.io/arduino-cli/0.35/}
\bibitem{Ione} Оффициальный сайт протокола grpc [Электронный ресурс]. — URL: \url{https://grpc.io/}
\bibitem{Ione} Индрасири Касун, Курупу Данеш. gRPC: запуск и эксплуатация облачных приложений. Go и Java для Docker и Kubernetes. - СПб.: Питер, 2021. - 224с.: ил. - (Серия “Бестселлеры O’Reily”)
\end{thebibliography}

%\bibliographystyle{gost780uv}

%\bibliography{refs}
\appendix
\section{Исходный код dockerfile, унифицирующий настройки среды запуска системы тестирования}
\begin{Verbatim}[fontsize=\small, numbers=left]
FROM ubuntu

ARG path_to_tests_folder="./Tests"

LABEL EMAIL=gorka19800@gmail.com

#install all the necessary libs and apps
RUN apt-get update
RUN apt-get dist-upgrade -y
RUN echo "8"| apt-get install -y qttools5-dev-tools
RUN apt-get install -y git python3 cmake qtbase5-dev g++ libqt5svg5-dev
 libqt5x11extras5-dev qtscript5-dev libboost-system-dev zlib1g zlib1g-dev
#setup git
RUN git config --global user.email "gorka19800@gmail.com"
RUN git config --global user.name "Test suit"
#clone repo and prepare for building kumir-to-arduino translator
RUN mkdir /home/Sources
WORKDIR /home/Sources/
RUN git clone https://github.com/CaMoCBaJL/kumir2
WORKDIR kumir2/
RUN git pull
RUN git checkout translator_tests
RUN git merge -s ours --no-edit origin/ArduinoFixes
RUN mkdir build
WORKDIR build/
#build translator
RUN cmake -DUSE_QT=5 -DCMAKE_BUILD_TYPE=Release ..
RUN make -j 18
#start tests
WORKDIR ../kumir_tests/
RUN touch test_results.log
RUN python3 test_script.py -d -o ./test_results.log
-tr ../build/bin/kumir2-arduino -t \$path_to_tests_folder
\end{Verbatim}
\section{Исходный код скрипта, производящего тестирование транслятора}
\begin{Verbatim}[fontsize=\small, numbers=left]
import os
import sys
import subprocess

#constants
class CONSOLE_BG_COLORS:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class TEST_RESULT_STATE:
    COMPLETED = 1
    MISSING_EXPECTATION = 2
    COMPILER_ERROR_HAPPEND = 3
    FAILED = -1
    NONE = 0

COMPILER_ERROR_LABEL = "ERROR!"

EXPECTATION_FILE_EXTENTION = ".exp"
SOURCE_FILE_EXTENTION = ".kum"

CONTROL_CHARACTERS = ["\n", "\r", "\t", " "]
BYTES_TO_READ_COUNT = 1024
CHAR_THRESHOLD = 0.3
TEXT_CHARACTERS = ''.join(
    [chr(code) for code in range(32, 127)] +
    list('\b\f\n\r\t')
)
BINARY_CHAR_EXAMPLE = '\x00'

TESTS_FOLDER_NAME = "Tests"

ARGS = {"help": ["-h", "--help"],
        "translator": ["-tr", "--translator"],
        "output": ["-o", "--output"],
        "duplicate": ["-d", "--duplicate"],
        "skip-successfull": ["-ss", "--skip-successfull"],
        "skip-failed": ["-sf", "--skip-failed"],
        "skip-without-expectation": ["-swe", "--skip-without-expectation"],
        "skip-with-compiler-error": ["-sce", "--skip-with-compiler-error"],
        "brief": ["-b", "--brief"],
        "path-to-tests": ["-t", "path-to-tests"]
        }

ERRORS = {
    "wrong input": "Wrong args input - you should type path to file after -c or
     -o flags!",
    "file not exist": "File doesn't exist!",
    "wrong file extention": "File extention for translator is not correct! It should
     be a bin-file.",
    "no path to tests": "Wrong args input - you should type path to tests folder
     after -t flag!"
}

#data structure to store test results
class TestResult:

    __text_color = CONSOLE_BG_COLORS.OKGREEN
    __header_text = ""
    SKIPPED_TEST_TYPES = [TEST_RESULT_STATE.NONE]

    def __init__(self, name: str, source: str, expectation: str, result: str):
        self.name = name
        self.source_file_name = source
        self.expectation_file_name = expectation
        self.resultFileName = result
        self.state = TEST_RESULT_STATE.NONE

    def __str__(self):
        self.__setup_output()
        additional_test_data = f'''
        Test group expectations: {self.expectation_file_name}
        Test group results: {self.resultFileName}. 
        To get more detail info about comparison results, print:
        vimdiff {self.source_file_name} {self.expectation_file_name}
         {self.resultFileName}
        or vimdiff {self.expectation_file_name} {self.resultFileName}
        {CONSOLE_BG_COLORS.ENDC}
        '''
        return f'''{self.__text_color}
        Test {self.name}.
        {self.__header_text}
        Sources for the test: {self.source_file_name}
        {additional_test_data if self.state is TEST_RESULT_STATE.COMPLETED
         or self.state is TEST_RESULT_STATE.FAILED else ""}
        '''

    def __setup_output(self):
        if self.state == TEST_RESULT_STATE.COMPLETED:
            self.__text_color = CONSOLE_BG_COLORS.OKGREEN
            self.__header_text = "Congratulations! Test completed successfully!"
        elif self.state == TEST_RESULT_STATE.MISSING_EXPECTATION:
            self.__text_color = CONSOLE_BG_COLORS.OKCYAN
            self.__header_text = "Oh! Test didn't complete: no expectation"
        elif self.state == TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND:
            self.__text_color = CONSOLE_BG_COLORS.WARNING
            self.__header_text = "Oh! Test didn't complete: compiler error"
        elif self.state == TEST_RESULT_STATE.FAILED:
            self.__text_color = CONSOLE_BG_COLORS.FAIL
            self.__header_text = "Sorry, but test failed..."

class TestSection:

    def __init__(self, section_name) -> None:
        self.name = section_name
        self.test_results = []
    
    def __str__(self) -> str:
        columns, _ = os.get_terminal_size()
        if (len(self.test_results) > 0):
            return f"""
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            Test section {self.name} starts here:
            {os.linesep.join(list(map(lambda test_result: str(test_result),
             self.test_results)))}
            End of {self.name} section tests
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            """
        
        return ''

#functions
def remove_control_characters(data_array):
    result = []
    for i in data_array:
        for cc in CONTROL_CHARACTERS:
            i = i.replace(cc, "")

        if i:
            result.append(i)

    return result

def get_file_data(filename):
    if not os.path.exists(filename):
        return ''
    file = open(filename, "r")
    result = file.readlines()
    file.close()
    return result

def has_errors(text):
    return COMPILER_ERROR_LABEL in text

def process_sources(source_filename, path_to_translator):
    path, _ = os.path.splitext(source_filename)
    result_filename = path + ".kumir.c"

    #call kumir2-arduino with params: 
    --out="path_to_cwd/results/test_name.kumir.c" -s ./test_name.kum
    popen = subprocess.Popen([path_to_translator,
                              f'--out={result_filename}',
                              '-s',
                              source_filename],
                             stdout=subprocess.PIPE)
    popen.wait()
    popen.stdout.read()

    return result_filename

def compare_data(expected_data, processed_data) -> TEST_RESULT_STATE:
    result_without_kumir_ref = remove_control_characters(processed_data[2:])
    expected_data = remove_control_characters(expected_data)

    if (has_errors(result_without_kumir_ref)):
        return TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND

    for i in range(len(result_without_kumir_ref)):
        if result_without_kumir_ref[i] != expected_data[i]:
            return TEST_RESULT_STATE.FAILED

    return TEST_RESULT_STATE.COMPLETED

def get_test_result_type_counters(test_sections):
    counters = {
        TEST_RESULT_STATE.COMPLETED: 0,
        TEST_RESULT_STATE.FAILED: 0,
        TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND: 0,
        TEST_RESULT_STATE.MISSING_EXPECTATION: 0,
    }

    for test_section in test_sections:
        for test_result in test_section.test_results:
            counters[test_result.state] += 1


    return counters

#log comparison results to file
def log_test_results(logs_filename, data_to_log: TestSection, log_to_console):
    result_type_counters = get_test_result_type_counters(data_to_log)
    completed_tests_count, failed_tests_count,
     compiler_error_happend_tests_count, 
     missing_expectations_tests_count = \
    [result_type_counters[k] for k in result_type_counters]

    log_data = []
    for test_section in data_to_log:
        test_section.test_results = list(filter
        (lambda test_result: test_result.state not in 
        TestResult.SKIPPED_TEST_TYPES, test_section.test_results))
        log_data.append(test_section)

    log_data_strings = list(map(lambda x: str(x), log_data))
    log_data_strings.insert(0, f'''
    There were found: {len(log_data)} tests.
    {CONSOLE_BG_COLORS.OKGREEN} Completed: 
    {completed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.FAIL} Failed: 
    {failed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.WARNING} With compiler error happend:
     {compiler_error_happend_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.OKCYAN} Missed expectation file: 
    {missing_expectations_tests_count} {CONSOLE_BG_COLORS.ENDC}''')

    if not os.path.exists(logs_filename):
        open(logs_filename, "a").close()

    log_file = open(logs_filename, "a")
    log_file.writelines(log_data_strings)
    log_file.close()

    if log_to_console:
        print(f"{os.linesep}".join(log_data_strings))

def is_binary_file(filename):
    file_stream = open(filename, 'rb')
    file_content = file_stream.read(BYTES_TO_READ_COUNT)
    file_stream.close()
    
    if not len(file_content):
        #file is empty, nothing to read
        return False
    
    if ord(BINARY_CHAR_EXAMPLE) in file_content:
        #file contains binary symbols
        return True
    
    binary_chars = file_content.translate(TEXT_CHARACTERS)
    return float(len(binary_chars)) / len(file_content) > CHAR_THRESHOLD

def validate_file_name(filename: str, is_log_file: bool):   
    if not os.path.exists(filename):
        print(filename + ERRORS.get("file not exist"))
        sys.exit(2)
    if not os.path.isfile(filename):
        print(ERRORS.get("wrong input"))
        sys.exit(2)
    if not is_log_file and not is_binary_file(filename):
        print(ERRORS.get("wrong file extention"))
        sys.exit(2)
        
def show_help():
    print(""" kumir2-arduino tester.
    Description:
    Approach of this app is to debug the work of kumir2 
    to arduino translator. It uses compiled translator's 
    instance, pre-builded locally on PC.
    To start the work you should input path to compiler 
    and path to logs file.
    Flags:
    [-h] [--help] - show help.
    
    [-tr] [--translator] ["the path to pre-builded kumir2 
    to arduino translator instance"] - show app what 
    translator instance to use.
    
    [-t] [--path-to-tests] ["the path to tests folder"] = 
    show app  the folder with test files.
    
    [-o] [--output] ["the path to log file"] - show app 
    where to store test logs.
    
    [-d] [--duplicate] - duplicate output to console.

    [-ss] [--skip-successfull] - skip open log info about 
    succesfully completed tests.

    [-sf] [--skip-failed] - skip open log info about failed tests.

    [-swe] [--skip-without-expectation] - skip open log info 
    about tests for which the file with expectations 
    was not found.

    [-sce] [--skip-with-compiler-error] - skip open log info 
    about tests ended with compiler error.

    [-b] [--brief] - skip open log info about all tests.
    """)

def process_args():
    result = ["", "", False, ""]
    if ARGS["help"][0] in sys.argv or ARGS["help"][1] 
    in sys.argv:
        show_help()
        sys.exit(2)

    if ARGS["skip-successfull"][0] in sys.argv or ARGS["
    skip-successfull"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.COMPLETED)
    
    if ARGS["skip-without-expectation"][0] in sys.argv 
    or ARGS["skip-without-expectation"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT_STATE
        .MISSING_EXPECTATION)

    if ARGS["skip-with-compiler-error"][0] in sys.argv or
     ARGS["skip-with-compiler-error"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT
        _STATE.COMPILER_ERROR_HAPPEND)

    if ARGS["skip-failed"][0] in sys.argv or ARGS[
    "skip-failed"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.FAILED)

    if ARGS["brief"][0] in sys.argv or ARGS["brief"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES = [
            TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND, 
            TEST_RESULT_STATE.COMPLETED, 
            TEST_RESULT_STATE.FAILED,
            TEST_RESULT_STATE.MISSING_EXPECTATION
            ]

    args = sys.argv[1:]
    for i in range(1, len(args)):
        if args[i - 1] in ARGS["translator"] or args[i - 1]
         in ARGS["output"] or args[i - 1] in ARGS
         ["path-to-tests"]:
            if (os.path.isfile(args[i])):
                validate_file_name(args[i], False if args[i - 1]
                 in ARGS["translator"] else True)

            if args[i - 1] in ARGS["translator"]:
                result[0] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["output"]: 
                result[1] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["path-to-tests"]:
                result[3] = os.path.abspath(args[i])
        elif args[i-1] in ARGS["duplicate"]:              
            result[2] = True
            
    return result

def get_files_with_absolute_paths(folder_name):
    path_to_folder = os.path.join(os.getcwd(), folder_name)
    files = 
    list(map(lambda x: os.path.join(path_to_folder, x),
     os.listdir(path=path_to_folder)))
    files.sort()

    return files

def get_source_and_expectation(dir_files):
    sources = []
    expectations = []
    for file in dir_files:
        if (os.path.isfile(file)):
            ext = os.path.splitext(file)[1]
            if (ext == EXPECTATION_FILE_EXTENTION):
                expectations.append(file)
            elif (ext == SOURCE_FILE_EXTENTION):
                sources.append(file)
    
    return [sources, expectations]

def get_folder_contents_full_paths(path_to_folder):
    return list(
        map(
            lambda x: os.path.join(os.sep, path_to_folder, x),
            os.listdir(path_to_folder)
            )
        )

def calculate_test_sections(path_to_tests_folder):
    result = []
    test_folder_paths = get_folder_contents_full
    _paths(path_to_tests_folder)
    for test_folder_path in test_folder_paths:
        if os.path.isfile(test_folder_path):
            continue

        result.append(TestSection(test_folder_path.
        split(os.sep)[-1]))
        test_paths = get_folder_contents_full_paths
        (test_folder_path)
        for test_dir_path in test_paths:
            source_files, expectation_files =
          get_source_and_expectation(get_folder_contents_full_paths
            (test_dir_path))
            if os.path.isfile(test_dir_path) or len
            (expectation_files) > 1 or len(source_files)
             < 1:
                continue
            
            result[-1].test_results.append(TestResult(
                test_dir_path.split(os.sep)[-1],
                source_files[0],
                "", ""
                )
            )

            if len(expectation_files) == 1:
                result[-1].test_results[-1]
         .expectation_file_name  = expectation_files[0]
                result[-1].test_results[-1].resultFileName
                 = process_sources(source_files[0],
                  args_data[0])
                result_data = get_file_data(result[-1]
               
                .test_results[-1].resultFileName)
                expected_data =
     get_file_data(result[-1].test_results[-1].expectation_file_name)
                result[-1].test_results[-1].state 
                = compare_data(expected_data, result_data)
            else: 
                result[-1].test_results[-1].state = 
                TEST_RESULT_STATE.MISSING_EXPECTATION

    return result

if __name__=="__main__":
    args_data = process_args()

    if not args_data[3]:
        print("Didn't find any test to execute. Shutting down.")       
        sys.exit()

    test_results = calculate_test_sections(args_data[3])

    log_test_results(args_data[1], test_results, args_data[2])
\end{Verbatim}
\end{document}