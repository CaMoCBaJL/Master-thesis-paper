\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}

\usepackage{graphicx}
\usepackage{xcolor}

\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{cmap}
\renewcommand{\rmdefault}{cmr} % Шрифт с засечками
\renewcommand{\sfdefault}{cmss} % Шрифт без засечек
\renewcommand{\ttdefault}{cmtt} % Моноширинный шрифт
\usepackage{tempora}
\usepackage{cite}
\usepackage{multirow}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\definecolor{linkcolor}{HTML}{FF4500}
\hypersetup{pdfstartview=FitH, linkcolor=linkcolor, urlcolor=linkcolor, colorlinks=true}

\addto\captionsrussian{\def\refname{ }}
\linespread{1.6}
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}
\renewcommand*\thesection{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\number\numexpr\value{subsection}\relax}

% ----------------------------------------------------------------
% elResourceRef command
% usage: 
% \elResourceRef{<resource name>}{<url to resource>}{date of the application}
\newcommand{\elResourceRef}[3]{#1 [Электронный ресурс] URL: #2 (дата обращения: #3)}
% ----------------------------------------------------------------
% image command
% usage: 
%\image{<image scale>}{<description text>}
\newcommand{\image}[2]{%
	\begin{center}%
	\label{img\arabic{imgCounter}}%
	\includegraphics[scale = #1]{\arabic{imgCounter}.png}\par%
	Рисунок \arabic{imgCounter} --- #2%
	\addtocounter{imgCounter}{1}%
	\end{center}%
}
%-----------------------------------------------------------------
% addBibItem command
% usage:
% \addBibItem{<\elResourceRef{<resource name>}{<url to resource>}{date of the application}>};
% \addBibItem{<custom item name>}
\newcommand{\addBibItem}[1]{%
\bibitem{Ione}#1%
\label{\arabic{labelCounter}}%
\addtocounter{labelCounter}{1}%
}
%-----------------------------------------------------------------
% sourceRef command
% usage:
% \noLabelSourceRef
\newcommand{\noLabelSourceRef}{{[\textcolor{green}{\hyperref[\arabic{hyrefCounter}]{\arabic{hyrefCounter}}\addtocounter{hyrefCounter}{1}}]}}
%-----------------------------------------------------------------
%custom counters declaration
\newcounter{imgCounter}
\setcounter{imgCounter}{1}
\newcounter{labelCounter}
\setcounter{labelCounter}{1}
\newcounter{hyrefCounter}
\setcounter{hyrefCounter}{1}
%------------------------------------------------------------------

\newtheorem{lem}{Лемма}

\begin{document}
\lstset{basicstyle = \small}
% Кафедра (в родительном падеже)
\chair{Кафедра информатики и программирования}

% Тема работы
\title{Разработка системы программирования ``КуМир роботы``}

% Курс
\course{2}
\group{273}

% Факультет (в родительном падеже)
\department{КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.04 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Пронина Антона Алексеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{М.\,В.\,Огнева}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{старший преподаватель} %должность, степень, звание
\saname{Е.\,Е.\,Лапшева}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{3}
\course{2}
% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{производственная распределенная (научно-исследовательская работа)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{18}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.09.2023}
\practFinish{15.01.2024}


% Наименование практики (только для практики, для остальных
% типов работ не используется)


% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)


% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)


% Год выполнения отчета
\date{2024}

\maketitle
% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering
\tableofcontents


\intro


Одним из наиболее интересных вопросов, требующих особого внимания в обучении информатике, является вопрос системы обучения программированию. Это связано с тем, что профессия специалистов в области информатики и информационных технологий в какой-то мере начинается со школы. Одним из прямых приложений программирования является робототехника. \par
Ввиду растущего интереса в сфере образования к обучению робототехнике в школе и широкой распространенности и глубокой степени интеграции современной образовательной системы с этим языком, появилась идея о разработке транслятора с языка КуМир в язык C++. Актуальность идеи заключается в снижении входного порога в область робототехники как со стороны ученика, предоставляя возможность, используя полученные навыки программирования в системе КуМир, заниматься разработкой роботов, так и со стороны преподавателя, уменьшая затраты на приобретение программных и аппаратных средств разработки. В качестве аппаратной платформы данной задачи был выбран электронный конструктор и удобная платформа быстрой разработки электронных устройств для новичков и профессионалов --- платы Arduino, ввиду низкой стоимости устройств, периферийных модулей, простоты разработки аппаратных устройств на базе этих плат, высокой модульности систем и их высокой распространенности среди робототехников. \par
Транслятор с языка КуМир в язык C++ стал отправной точкой процесса создания комплекса аппаратно-программных  и методических средств изучения робототехники в школе с использованием языка программирования КуМир. Важным аспектом комплекса является доступность и удобство изучения робототехники. Для повышения доступности изучения, было принято решение разработать отдельный клиент системы программирования КуМир “КуМир Роботы”, направленный на изучение робототехники на основе плат Arduino. \par
Цель работы --- разработка  системы программирования роботов на основе плат Arduino на базе исходных кодов системы программирования КуМир.
Для выполнения поставленной цели, требуется выполнить следующие задачи:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item проанализировать исходные коды системы программирования КуМир;
\item проанализировать историю развития технологий, используемых для разработки системы программирования;
\item доработка и устранение ошибок в исходном коде системы программирования КуМир;
\item проанализировать системы программирования плат Arduino и их аналоги;
\item разработать отдельный клиент для разработки роботов;
\item обновить используемые библиотеки и фреймворки для разработки среды программирования;
\item разработать плагин для взаимодействия с платами Arduino.
\end{itemize}
\section{Предметная область. Подходы, понятия, средства}
\subsection{Среда исполнения и язык программирования КуМир}
КуМир (Комплект Учебных МИРов) --- система программирования, предназначенная для поддержки начальных курсов информатики и программирования в средней и высшей школе с открытым исходным кодом \noLabelSourceRef. Спектр возможностей применения данной системы программирования ограничен, ряд стандартных команд позволяет разрабатывать небольшие приложения с целью изучения основ программирования на процедурных языках. \par
На данный момент язык КуМир --- это язык, с которого хорошо начать, чтобы освоить основы алгоритмического подхода и процедурный стиль программирования. Система КуМир \noLabelSourceRef в современном ее состоянии (с подсистемой ПиктоМир) состоит из расширяемого набора исполнителей (или роботов), набора систем программирования и вспомогательных утилит и программ. Расширяемый набор исполнителей (роботов) представляет собой отдельные самостоятельные программы и (или) электронно-механические устройства, имеющие собственное пультовое управление (интерфейс), а также возможность локального или сетевого управления из выполняющей системы. Набор систем программирования:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item система программирования КуМир на школьном алгоритмическом языке, состоящая из редактора-компилятора алгоритмического языка с многооконным интерфейсом, интегрированная с выполняющей системой. Система не является полноценным интерпретатором или компилятором школьного алгоритмического языка. Зачастую, программа на школьном алгоритмическом языке компилируется в некий промежуточный код (подобный подход был использован в языке Java), который затем интерпретируется и исполняется с автоматической генерацией точек останова по событиям и шагам (при пошаговом выполнении). В системе программирования КуМир также отсутствует отладчик в его классическом понимании. Это имеет свои причины, так как сильно упрощает процесс освоения и написания системы программирования КуМир, а также отладку программ. Все изменения используемых в школьной программе величин автоматически визуализируются на полях программы. Визуализируются и результаты логических операций. Кроме того, к системе можно подключать любого исполнителя (робота) из набора и программно управлять им;
\item система бестекстового, пиктографического программирования ПиктоМир. В ней учащийся собирает программу из команд исполнителя (робота). Управляющие конструкции языка представлены определенной параметрической организацией алгоритмов. Созданная учащимися программа при выполнении передает команды робота и получает его состояние; 
\item система программирования на производственном языке программирования С++, Python и т.п \noLabelSourceRef; 
\end{itemize}
\subsection{Архитектура системы программирования КуМир}
Помимо инструментов разработки, среда обладает рядом функциональных возможностей --- просмотр документации, создание и выполнение практикумов, работа с окном в свернутом режиме и пр. Стартовое окно системы программирования КуМир представлено на рисунке 1.
\image{0.7}{Внешний вид среды программирования КуМир} \par
С точки зрения кода, система программирования КуМир представляет собой монолитное приложение. Исходные коды разделены на 2 основные части:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item библиотеки;
\item плагины.
\end{itemize}
Существует ряд клиентов среды программирования КуМир --- для учителя, для ученика старших классов, стандартный клиент. Помимо клиентов, существуют отдельные приложения для компиляции и исполнения кода на языке программирования КуМир. Описанные выше приложения создаются при помощи разделяемого программного кода и вспомогательных инструментов. \par
К вспомогательным инструментам стоит отнести и ряд функций, упрощающих работу с системой сборки CMake \noLabelSourceRef. В исходных кодах можно найти функции упрощающие поиск библиотек для фреймворка QT, определения и установки файлов ресурсов при сборке, а также функции для сборки артефактов приложения(клиентов) из исходных кодов. \par
Для создания нового артефакта - клиента или приложения командной строки используется CMake-функция $kumir2\_add\_launcher$. По созданному конфигурационному файлу CmakeLists.txt с описанием нового клиента по аналогии с имеющимися, во время сборки приложения, программа-сборщик обнаружит файл конфигурации и с его помощью создаст клиент. Пример конфигурационного файла CmakeLists.txt приведен в листинге 1:
\begin{Verbatim}[fontsize=\small, numbers=left]
project(kumir2-robots)
cmake_minimum_required(VERSION 3.0)

find_package(Kumir2 REQUIRED)

kumir2_add_launcher(
   NAME            kumir2-robots
   SPLASHSCREEN    "splashscreen-classic.png"
  WINDOW_ICON     "window-icon-classic.png"
    APP_ICON_NAME   "kumir2-classic"
   X_ICONS_DIR     "../../../app_icons/linux/hicolor"
    WIN_ICONS_DIR   "../../../app_icons/win32"
   X_NAME          "Kumir Robots Edition"
    X_NAME_ru       "Кумир для роботов"
    X_CATEGORIES    "Education,X-KDE-Edu-Misc"
    CONFIGURATION   
  "CourseManager,Editor,ActorArduino, 
 ArduinoCodeGenerator\(preload=Files\), 
 KumirAnalizer\(preload=Files\),*CodeGenerator, 
 KumirCodeRun(nobreakpoints),!CoreGUI\(nosessions\)")
\end{Verbatim}
\begin{center}
Листинг 1 --- Пример содержимого файла CMakeLists.txt для нового клиента системы программирования КуМир
\end{center}
Функция $kumir2\_add\_launcher$ позволяет декларативно настроить результат сборки --- указать его название, иконку, а также ряд зависимостей для сборки приложения.\par
Клиент среды программирования состоит из плагинов и исполнителей. Плагины ссылаются на библиотеки КуМир-а, предоставляя конкретные реализации на основе контрактов \noLabelSourceRef, описываемых моделями библиотек.  \par 
Среди инструментов разработчика существуют скрипты для кодогенерации оснастки исполнителей, развертывания приложения в разных операционных системах и генерации CMake-скриптов. \par
Библиотеки представляют собой набор базовых сущностей, реализующих определенную часть функционала. В подавляющем большинстве, классы, описывающие область знания не содержат в себе логики работы с данной областью и представляют лишь анемичные модели \noLabelSourceRef, \noLabelSourceRef для хранения состояния. Для работы с моделями используются генераторы или фабрики. Среди библиотек существует собственная реализация AST-дерева \noLabelSourceRef. Библиотека содержит модели, описывающие выражения, типы, модули, алгоритмы, переменные и лексемы. Программный код, использующий данные модели представляет собой плагины для кодогенерации. \par
Кроме AST-деревьев, при помощи библиотек описаны:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item модели уведомлений об ошибках;
\item модели для работы с XML-документацией;
\item модели для работы с плагинами(базовый функционал, использующийся для создания конкретных реализаций);
\item модели для работы с кодировками;
\item промежуточные модели для работы с LLVM.
\end{itemize}
Описанные выше библиотеки используются для создания плагинов --- основных блоков приложений. Система плагинов позволяет гибко конфигурировать и изменять набор пользовательских функций. Плагин может инкапсулировать как функции по трансляции или компиляции языка КуМир в другой язык, так и графическую оболочку приложения, отдельные части его интерфейса. \par
Список функций, разделенных при помощи плагинов приведен ниже:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item графический интерфейс;
\item режим учителя;
\item статический анализ программного кода;
\item генерация программного кода с языка программирования КуМир в платформо-ориентированный код;
\item компиляция программного кода на языке программирования КуМир;
\item запуск кода на языке программирования КуМир для выбранной архитектуры процессора и операционной системы;
\item генерация программного кода с языка программирования КуМир в  инструкции LLVM;
\item поддержка языка программирования Python 3.
\end{itemize}
В ходе ВКР бакалавра был разработан плагин для генерации программного кода с языка программирования КуМир в язык программирования С++, а также исполнитель “Ардуино” \noLabelSourceRef, предоставляющий набор базовых операций для работы с платами Arduino. Эти доработки являются ключевыми составляющими для разработки отдельного клиента “КуМир Роботы”, предназначенного для программирования роботов на базе плат Arduino. \par
Анализ архитектуры проекта и имеющихся инструментов позволил определить необходимый функционал для разработки нового приложения. Первым шагом на пути разработки стал анализ зависимостей приложения и обновление основной зависимости --- фреймворка QT.
\subsection{Обновление зависимостей проекта}
Обновление зависимостей проекта является важной частью его поддержки и сопровождения. Вот несколько причин, почему это необходимо:
\begin{enumerate}
\item исправление ошибок и уязвимостей: Одна из основных причин обновления зависимостей --- исправление ошибок и уязвимостей в используемых библиотеках. Разработчики постоянно работают над улучшением своего программного обеспечения и выпускают исправления проблем, которые были обнаружены. Если вы не обновляете зависимости, ваш проект может содержать уязвимости, которые могут быть использованы злоумышленниками;
\item улучшение производительности и функционала: Обновление зависимостей может также привести к улучшению производительности вашего проекта и добавлению новых функций. Разработчики могут оптимизировать код, исправлять узкие места и добавлять новые возможности в новых версиях библиотек. Если вы не обновляете зависимости, вы можете упустить эти улучшения и новые возможности;
\item совместимость с другими зависимостями: Когда вы обновляете одну зависимость, это может потребовать обновления других зависимостей, чтобы сохранить совместимость между ними. Когда вы используете устаревшие версии библиотек, вы можете столкнуться с проблемами совместимости, которые могут привести к ошибкам или неожиданному поведению вашего проекта;
\item поддержка сообщества и документация: Обновление зависимостей помогает поддерживать активное сообщество вокруг вашего проекта. Разработчики библиотек постоянно работают над улучшением своего программного обеспечения и предоставляют обновления с новыми возможностями или исправлениями. Если вы не обновляете зависимости, вы можете упустить эти улучшения и использовать менее поддерживаемые версии библиотек.
\end{enumerate}
В целом, обновление зависимостей --- важный элемент поддержки проекта. Оно помогает сохранить безопасность, улучшить производительность, добавить новые функции и поддерживать совместимость со сторонними библиотеками \noLabelSourceRef. \par
Система программирования КуМир имеет ряд зависимостей --- библиотек и фреймворков, используемых для разработки. Основными являются:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item фреймворк QT;
\item система сборки CMake;
\item интерпретатор языка программирования Python;
\item библиотека Zlib;
\item библиотека boost;
\item библиотека LLVM.
\end{itemize}
Фаза активной разработки среды и языка программирования КуМир была прекращена в 2014 году. Судя по состоянию репозитория с исходными кодами \noLabelSourceRef, последние изменения, вносимые в код лишь исправляют небольшие недочеты и недоработки. На данный момент, развитие языка программирования КуМир приостановлено, изменения, в корне меняющие функционал системы программирования не планируются \noLabelSourceRef. Большинство исходного кода написано с использованием фреймворка QT, четвертой версии. Поддержка данной версии была прекращена в 2015 году и признана устаревшей \noLabelSourceRef. \par
Установка данной версии фреймворка проблематична ввиду отсутствия пакетированных образов. Альтернативой поиску необходимой зависимости является сборка пакета из исходных кодов. Оба рассмотренных выше варианта позволят безопасно разрабатывать приложение, с минимальным риском возникновения ошибок в результате сборки. Однако, использование неактуальных версий зависимостей предполагает наличие потенциальных уязвимостей, проблем с развертыванием приложений на устройствах потребителей, а также ряд других уязвимостей связанных с прекращением поддержки \noLabelSourceRef. \par 
Для разработки отдельного клиента с новым функционалом для программирования роботов на базе исходных кодов системы программирования КуМир, потребовалось произвести миграцию исходных кодов на поддерживаемую версию фреймворка $QT - QT 5.15$. Среди основных сложностей при миграции стоит выделить следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item изменение программного интерфейса фреймворка;
\item несовместимость части библиотек с новой версией;
\item несовместимость с системой сборки.
\end{itemize}
После изменения версии используемого фреймворка на более современную, в первую очередь пришлось решать проблемы с системой сборки. В новой версии фреймворка разработчики приняли решение об изменении подхода к именованию основных строительных блоков и изменению пакета, содержащего данный функционал. \par
Далее возник ряд предупреждений об использовании устаревших инструкций, например, в версии фреймворка отказались от использования отдельных перечислений, решив использовать одно общее перечисление \noLabelSourceRef, описывающее широкий спектр свойств. Иными словами, вместо $QT::Color::Blue$, теперь стоит использовать $QT::Blue$. Подобные недочеты составили 70\% всех изменений, внесенных при обновлении зависимости проекта. \par
Серьезной проблемой стало обновление модуля для работы с пользовательской документацией, отображенной на рисунке 2. 
\image{0.7}{Внешний вид плагина для работы с документацией} \par
Файлы с документацией представляют собой xml-файлы. Основная сущность, используемая для разбора этих файлов была помечена устаревшей в новой версии фреймворка. Ввиду кроссплатформенности приложения, код парсинга xml-документов различался для различных операционных систем. 
Последней сложностью, возникшей при миграции стало изменение кода обработки пользовательского ввода с клавиатуры. При изучении функционала системы, собранной из исходных кодов, периодически возникала ошибка, приводящая к закрытию приложения. Профилирование приложения не позволило определить причину ошибки. Проблемным местом оказался модуль обработки пользовательского ввода с клавиатуры. Код модуля использовал библиотеку X11 \noLabelSourceRef. \par
В результате обновления миграции приложения удалось повысить доступность приложения для современных систем, повысить его надежность, а также упростить дальнейшую разработку решив проблему совместимости версий зависимостей проекта. \par
Миграция приложения на новую версию фреймворка стала отправной точкой в процессе разработки отдельного клиента для программирования роботов. Была создана отдельная ветка в репозитории, где была произведена миграция и началась разработка приложения “КуМир Роботы”. Помимо создания конфигурации и определения необходимых зависимостей для приложения, был разработан плагин для работы с платами Arduino. Перед разработкой данного расширения был  произведен анализ существующих средств аппаратной обработки плат Arduino.
\section{Аппаратно-программный комплекс Arduino}
\subsection{Робототехника в школе}
Arduino --- комплекс аппаратно-программных средств с открытым исходным кодом, обладающий низким порогом вхождения как со стороны программирования, так и со стороны электроники. Электронные платы способны считывать и генерировать входные и выходные сигналы. Для передачи последовательности команд управления плате используется язык программирования Arduino и соответствующая среда исполнения. Многолетняя история развития платформы Arduino включает в себя тысячи проектов --- от небольших устройств до крупных научных инструментов. Сообщество разработчиков данной платформы состоит из программистов различного уровня --- от любителей до профессионалов, собравших и систематизировавших свой опыт взаимодействия с Arduino для помощи в вопросах разработки проектов, полезный как новичкам, так и профессионалам. \par
Использование платформы Arduino в педагогической деятельности открывает новые возможности для студента и школьника. Проекты, реализуемые в учебном процессе в образовательных учреждениях, могут выполняться и развиваться дома. \par
В последние годы во многих школах активно организуется основная и дополнительная образовательная деятельность учащихся, связанная с освоением элементов робототехники \noLabelSourceRef. Использование платформы Arduino для образовательных учреждений позволяет получить возможность развить навыки программирования на практике, а также освоить азы схемотехники, дает возможность обучающимся освоить основные приемы разработки аппаратной и программной части автономных автоматизированных комплексов. Исследователи вопроса актуальности изучения робототехники на базе платформы Arduino в образовательном процессе отмечают повышение креативности учащихся \noLabelSourceRef, активное формирование и оттачивание профессиональных навыков и умений, а также развиваются и осваиваются компетенции естественно-научной направленности, связанные с физико-техническими дисциплинами \noLabelSourceRef.
\subsection{Анализ инструкций и плат Arduino}
Семейство плат Arduino включает в себя несколько моделей, которые отличаются по характеристикам, возможностям и цене:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item Arduino Uno: Это самая популярная и распространенная модель платы Arduino. Она оснащена микроконтроллером ATmega328P и имеет несколько цифровых и аналоговых входов/выходов. На плате есть разъемы для подключения сенсоров, дисплеев, моторов и других компонентов. Arduino Uno имеет простой интерфейс, что делает его идеальным для начинающих. Платы полностью совместимы с наборами плат расширения, позволяющими увеличить спектр возможностей применения платы --- от добавления ethernet до портативного зарядного устройства с аккумулятором;
\item Arduino Mega: Этот микроконтроллер имеет более мощный процессор ATmega2560, обладает большим количеством входов/выходов и памяти. Arduino Mega обычно используется для более сложных проектов, требующих большего количества подключенных компонентов;
\item Arduino Leonardo/Arduino Micro: Эти модели оснащены микроконтроллерами ATmega32U4 и обладают возможностью эмуляции устройств USB, таких, как клавиатура или мышь. Arduino Leonardo/Arduino Micro обычно используются для создания интерактивных устройств, таких как игровые контроллеры;
\item Arduino Nano: Эта небольшая и компактная модель имеет те же характеристики, что и Arduino Uno, но в более удобном форм-факторе. Arduino Nano обычно используется в проектах, где необходимо сохранить место на плате. Пригодятся, если вам нужно собрать очень компактное устройство;
\item Arduino Due: Эта модель оснащена микроконтроллером ARM Cortex-M3, который позволяет разработчикам выполнять сложные вычисления и работать с более высокой производительностью. Arduino Due часто используется для создания проектов, требующих большой вычислительной мощности.
\end{itemize}
Кроме вышеперечисленных моделей, существуют и другие варианты, такие как Arduino Y?n, Arduino Nano Every, Arduino MKR и другие. Каждая из них имеет свою спецификацию и предназначение, что позволяет выбрать подходящую модель в зависимости от конкретных потребностей и требований вашего проекта. \par
Семейства плат отличаются друг от друга рядом технических характеристик, а именно: 
\begin{itemize}[label = •, itemindent = 0.5cm]
\item микроконтроллер: Каждая плата Arduino основана на определенном микроконтроллере, таком как ATmega328P, ATmega2560, ATmega32U4 и других. Разные микроконтроллеры имеют разные характеристики, такие как частота работы, объем памяти и количество входов/выходов;
\item форм фактор: Существует несколько различных форм-факторов плат Arduino, таких, как Arduino Uno, Arduino Mega, Arduino Nano и другие. Каждая плата имеет свои уникальные размеры и разъемы для подключения различных модулей и дополнительных компонентов;
\item функциональность: В разных семействах плат Arduino могут быть различные функциональные возможности. Например, некоторые платы могут иметь встроенный WiFi или Bluetooth модуль, возможность работы с сенсорами или поддержку расширений для специфических задач;
\item напряжение питания: Некоторые платы могут работать от батарейного питания или низкого напряжения, в то время как другие могут требовать более высокого напряжения;
\item цена: Разные платы Arduino имеют разные цены в зависимости от их характеристик и функциональности. Некоторые платы могут быть более дорогими из-за дополнительных функций или встроенных модулей.
\end{itemize}
ля процессоров с различной архитектурой процесс прошивки будет отличаться --- для каждой архитектуры имеется своя программа, осуществляющая прошивку платы. Несмотря на это, программирования плат Arduino осуществляется при помощи скетчей --- программ на специализированном языке программирования Arduino. Язык является подмножеством языка С++ и содержит набор базовых, кроссплатформенных функций. \par
В качестве целевой платформы были выбраны платы Arduino Uno ввиду широкой распространенности в сообществе, низкой стоимости и простоты использования.
\subsection{Программные средства взаимодействия с платами Arduino}
При работе с платами Arduino вопросы, касающиеся работы с платами решаются при помощи Arduino IDE. Интерфейс приложения показан на рисунке 3. \newpage
\image{0.9}{Интерфейс программы Arduino IDE} \par
Для передачи последовательности команд управления плате используется язык программирования Arduino и соответствующая среда исполнения. Программное обеспечение может быть легко использовано на любой операционной системе \noLabelSourceRef. \par
На текущей момент существует две версии среды программирования Arduino IDE. Среда программирования позволяет автоматически обнаруживать подключенные к устройству платы, производить их прошивку, а также обрабатывать поступающие с подключенной платы сигналы в реальном времени. Приложение портировано на все операционной системы, программный код для работы с платами имеет общую реализацию, учитывающую различия операционных систем, имеющие значительное влияние на работу с платами. \par
Исходный код системы программирования Arduino IDE как первой \noLabelSourceRef, так и второй \noLabelSourceRef версии открыт для просмотра и редактирования. Для анализа исходных кодов было решено выбрать более современную версию приложения и рассмотреть алгоритмы взаимодействия приложения с платами. \par
Вторая версия приложения разработана при помощи языка программирования Typescript \noLabelSourceRef и библиотеки react-js \noLabelSourceRef. Приложение может работать как в браузере, так и локально на устройстве пользователя. \par
При авторизации в приложении у пользователя появляется возможность установить расширение для браузера, как показано на рисунке 4 и начать работу. \par
\image{0.9}{Предложение установить дополнительное ПО для старта работы с Arduino} \par
В репозитории среды программирования можно найти информацию об использовании приложения Arduino-cli \noLabelSourceRef, \noLabelSourceRef для взаимодействия с платами. Arduino-cli --- это инструмент командной строки для управления платами Arduino без использования среды разработки Arduino IDE. Он позволяет компилировать, загружать и управлять скетчами Arduino с помощью командной строки, что делает его удобным инструментом для автоматизации процесса разработки и интеграции Arduino в различные среды разработки и рабочие процессы. Arduino-cli поддерживает широкий спектр плат Arduino и различных плат расширения, а также предоставляет возможность установки дополнительных библиотек и платформ. \par
Приложение обладает набором удобных команд при помощи которых можно организовать сообщение и передачу данных. Среди доступных функций требовалось внедрить в собственный клиент следующие:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item компиляция скетча;
\item поиск плат;
\item прошивка выбранной платы;
\item поиск плат в реальном времени.
\end{itemize}
Приложение предоставляет два способа для интеграции. Первый предполагает использование приложения по прямому назначению(в качестве приложения командной строки). Общение между потребителем и приложением осуществляется при помощи вызова команд с определенным набором аргументов. Arduino-cli может работать в фоновом режиме --- имеется возможность запуска приложения как системную службу или демона в зависимости от операционной системы. \par
Второй способ обмена информации между приложением и потребителями является открытие grpc-канала \noLabelSourceRef, \noLabelSourceRef. Часть сообщений передается через дуплексный канал связи. Примером такого взаимодействия является опрос подключенных к устройству пользователя плат Arduino. Остальные сообщения передаются по симплексному каналу связи. \par
В результате анализа было решено разработать плагин для интеграции приложения Arduino-cli как приложения командной строки и предоставления описанных выше возможностей пользователям. С точки зрения имеющейся архитектуры была добавлена библиотека, содержащая контракты для встраивания приложений командной строки, а также был разработан плагин, отвечающий за поиск, соединение и работу с Arduino-cli. 
\subsection{Система программирования ``КуМир роботы``}
По окончанию анализа исходных кодов среды и языка программирования  КуМир, была составлена схема доработки исходного кода проекта для реализации отдельного клиента среды программирования для изучения робототехники. Схема дорабатываемых библиотек в разрезе архитектуры проекта приведена на рисунке 5. Схема добавленных плагинов в разрезе архитектуры проекта приведена на рисунке 6.
\image{0.9}{Разработанная библиотека(выделена рамкой)}
\image{0.9}{Список разработанных плагинов для работы с платами Arduino} \par
При создании файла конфигурации нового приложения было решено не включать в него стандартный набор исполнителей - Робот, Кузнечик и пр. При работе в данном клиенте единственным доступным исполнителем является исполнитель “Ардуино”, предоставляющий следующие функции:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item функции аналогового и дискретного ввода/вывода сигналов платы;
\item функции для соединения ПК с платами;
\item набор констант для работы с портами платы.
\end{itemize}
Плагины arduino-compiler и arduino-codegenerator работают по аналогии с уже существующими плагинами для КуМира. Использование этих плагинов при разработке нового приложения не составляет сложностей. Плагина Arduino-cli накладывает ряд дополнительных ограничений на пользователя, связанных с установкой дополнительного ПО, а именно самой программы Arduino-cli. \par
В связи с добавлением внешней зависимости для приложения плагин для работы с платами Arduino содержит виджет проверки состояния доступности программы Arduino-cli. Внешний вид виджета представлен на рисунке 7. \par
\image{0.9}{Внешний вид виджета для возможности разрабатывать платы Arduino} \par
Виджет открывается при запуске приложения. Проверка возможности работы включает в себя 3 этапа:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item проверка установки arduino-cli --- поиск установленного на устройстве пользователя приложения;
\item проверка доступности arduino-cli --- проверка наличия прав и корректности установки приложения;
\item поиск подключенных плат --- опрос портов устройства пользователя на предмет наличия подключенных плат.
\end{itemize}
Первые 2 пункта проверки являются обязательными и должны быть успешно пройдены для старта работы. Результат работы виджета сохраняется в настройках приложения. Проверка возможности работы может быть произведена не только при запуске клиента ``КуМир Роботы``. Кнопка с соответствующим названием находится в меню ``Настройки``. \par
В случае успешного прохождения проверок функционал по работе с платами доступен. Иначе часть возможностей становится недоступной. При попытке воспользоваться недоступной частью функционала, система уведомляет пользователя о невозможности действия.
Виджет работает по принципу конечного автомата. Ряд состояний, определяющих работу виджета приведен ниже:
\begin{enumerate}
\item проверка установки;
\item проверка доступности;
\item arduino-cli не доступна;
\item поиск плат;
\item платы не найдены;
\item одна или несколько плат найдены;
\item проверки успешно пройдены.
\end{enumerate}
В случае завершения работы виджета в состояниях 1-3, пользователю предлагается перейти по ссылке на официальный сайт приложения и установить его. Для проверки корректности установки Arduino-cli виджет пытается обратиться по 1 из стандартных путей установки приложения в системе. В случае установки приложения по пути, отличающемуся от стандартного, пользователь может добавить путь в файловой системе к установленному приложению. \par
Для отслеживания списка подключенных плат используется команда $board list$ с флагом $-w$. Список подключенных плат доступен во вкладке ``Платы``. При наведении пользователь видит выпадающий список с набором подключенных к устройству плат. Для различия плат с одинаковыми именами используется параметр $FQBN$. Представляет собой строку, которая содержит информацию о модели платы, архитектуре микроконтроллера и версии платформы Arduino. $FQBN$ используется в Arduino IDE и других инструментах для определения параметров и компиляции программного кода для конкретной платы Arduino. Примером $FQBN$ может быть $"arduino:avr:uno"$, где $"arduino"$ указывает на производителя, $"avr"$ --- на архитектуру микроконтроллера и $"uno"$ --- на модель платы. \par
Разработанная система программирования значительно упрощает процесс изучения робототехники. Предыдущая итерация проекта представляла собой консольное приложение-транслятор для генерации скетча для платы Arduino по программному коду на языке программирования КуМир. Отдельный клиент предоставляет возможность интерактивного изучения робототехники используя один интерфейс как для отслеживания состояния плат, так и для работы с платами напрямую --- их прошивки, компиляции и настройки скетча. \par

\conclusion

В ходе работы были изучены материалы по системе программирования КуМир, аппартно-программной платформе Arduino и фреймворку QT. Были решены следующие задачи:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item проанализированы исходные коды системы программирования КуМир;
\item проанализирована история развития технологий, используемых для разработки системы программирования;
\item были произведены доработки и устранение ошибок в исходном коде системы программирования КуМир;
\item проанализировано семейство плат Arduino и их аналоги;
\item разработан отдельный клиент для разработки роботов;
\item обновлены используемые библиотеки и фреймворки для разработки среды программирования;
\item разработан плагин для взаимодействия с платами Arduino.
\end{itemize} \par
Разработка приложения ``КуМир роботы`` прошла начальную стадию развития --- произошло логическое и физическое разделение исходного кода от основной массы, был разработан ряд отдельных плагинов, формуриующих наполнение приложения. В дальнейшем, планируется ряд доработок для повышения удобства пользования приложения. Список возможных доработок приведен ниже:
\begin{itemize}[label = •, itemindent = 0.5cm]
\item профилирование приложения с целью поиска и устранения утечек памяти;
\item создание виджета, демонстрирующего устройство подключенной платы;
\item создание плагина-шаблонизатора плат для выбора .h-файла, содержащего набор предзаданных портов и констант;
\item динамическое изменение статического анализатора при помощи внедренного шаблона платы;
\item создание библиотеки шаблонов, позволяющей пользователям делиться шабонами роботов;
\item интеграция с API github для повышения доступности библиотек шаблонов --- добавление возможности подключения в клиент репозитория с шаблонами;
\item рефакторинг компилятора языка программирования КуМир --- отказ от использования кода фреймворка QT.
\end{itemize} \par
По окончанию реализации и тестирования среды программирования ``КуМир роботы`` для разработки роботов, планируется спроектировать и разработать одного или нескольких роботов на базе аппаратного комплекса Arduino для опробации разработки в школах. \par

\begin{thebibliography}{99}
\bibitem{Ione} Оффициальный сайт КуМир [Электронный ресурс]. — 2022. — URL: \url{https://www.niisi.ru/kumir/.} Загл. с экр. Яз. рус.
\bibitem{Ione} Леонов, А. Г. Методика преподавания основ алгоритмизации на базе системы «КуМир» [Электронный ресурс]. — 2009. — URL:  \url{https://inf.1sept.ru/view\_article.php?ID=200901701.} Загл. с экр. Яз. рус.
\bibitem{Ione} Кушниренко, А. Г. докл. ПиктоМир: пропедевтика алгоритмического языка (опыт обучения программированию старших дошкольников) // Большой московский семинар по методике раннего обуч. информатике. — M.: ИТО-РОИ, 2012.
\bibitem{Ione} Манаев Р.Г. ТЕХНОЛОГИЯ ВНЕДРЕНИЯ НЕПРЕРЫВНОЙ ИНТЕГРАЦИИ В КРУПНЫХ ВЫСОКОНАГРУЖЕННЫХ СИСТЕМАХ С МИНИМИЗАЦИЕЙ ОШИБОК И ВРЕМЕННЫХ ПОТЕРЬ СО СТОРОНЫ РАЗРАБОТЧИКОВ // Инновации и инвестиции. 2020. №12.
\bibitem{Ione} Маклафлин Б., Поллайс Г., Уэст Д. Объектно-ориентированнный анализ и проектирование. - СПб.: Питер, 2013. - 608с.: ил.
\bibitem{Ione} Фаулер, Мартин. Шаблоны корпоративных приложений. : Пер. с англ. - М. : ООО “И.Д. Вильямс”, 2016. - 544с.: ил. - Парал. тит. англ. 
\bibitem{Ione} Эванс, Эрик. Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем.: Пер. с англ. - СПб.: ООО “Диалектика”, 2020 - 448с.: ил. - Парал. тит. англ.
\bibitem{Ione} Ахо, Альфред В., лам, Моника С., Сети, Рави, Ульман, Джеффри Д. Компиляторы: принципы, технологии и инструментарий. 2-е изд.: Пер. с англ. - М.: ООО “И.Д. Вильямс”, 2018 - 1184с.: ил. - Парал. тит. англ.
\bibitem{Ione} Пронин А.А., Синельников Е.А. Модули в языке программирования КуМир 2.0 // Информационные технологии в образовании: сборник / редакционная коллегия: С. Г. Григорьев [и др.]. – Саратов: Саратовский университет [издание], 2022. – Вып. 5: материалы XIV Всероссийской научно-практической конференции «Информационные технологии в образовании» (ИТО-Саратов-2022), Саратов, 28-29 октября 2022 г. – 290 с. : ил. (9,19Мб). – URL: https://sgu.ru/node/197426. – Режим доступа: Свободный. Продолжающиеся издания СГУ на сайте www.sgu.ru. [207-211]
\bibitem{Ione} Смирнов Максим докл. Модернизация унаследованных приложений // конференция ArchDays 2023
\bibitem{Ione} Исходный код среды исполнения КуМир [Электронный ресурс]. — URL: \url{https://github.com/a-a-maly/kumir2} Загл. с экр. Яз. рус
\bibitem{Ione} Кушниренко, А. Г. Опыт интеграции цифровой образовательной среды КуМир в платформу Мирера // Объединенная конференция "СПО: от обучения до разработки": материалы конференции / Под ред. В. Л. Чёрный. — МАКС Пресс, 2022. — С. 24–30.
\bibitem{Ione} Список версий фреймворка QT [Электронный ресурс]. — URL: \url{https://wiki.qt.io/Portal:Quick\_Access}
\bibitem{Ione} Вареница Виталий Викторович, Марков Алексей Сергеевич, Савченко Владислав Вадимович, Цирлов Валентин Леонидович ПРАКТИЧЕСКИЕ АСПЕКТЫ ВЫЯВЛЕНИЯ УЯЗВИМОСТЕЙ ПРИ ПРОВЕДЕНИИ СЕРТИФИКАЦИОННЫХ ИСПЫТАНИЙ ПРОГРАММНЫХ СРЕДСТВ ЗАЩИТЫ ИНФОРМАЦИИ // Вопросы кибербезопасности. 2021. №5 (45).
\bibitem{Ione} Амини Камран. Экстремальный Cи. Параллелизм, ООП и продвинутые возможности. — СПб.: Питер, 2021. — 752 с.: ил. — (Серия «Для профессионалов»).
\bibitem{Ione} Бобков В.А., Черкашин А.С. Обработка и визуализация пространственных данных на гибридном вычислительном кластере // Прикладная информатика. 2014. №4 (52).
\bibitem{Ione} Шабалин, К. В. Формирование креативных способностей школьников при выполнении проектов на базе платформы Arduino / К. В. Шабалин // Педагогическое образование в России. — 2022. — No 2. — С. 135–140.
\bibitem{Ione} Глазов Сергей Юрьевич, Сергеев Алексей Николаевич, Усольцев Вадим Леонидович ВОЗМОЖНОСТИ ПРИМЕНЕНИЯ ПЛАТФОРМЫ АRDUINO В УЧЕБНОМ ПРОЦЕССЕ ПЕДАГОГИЧЕСКОГО ВУЗА И ОБЩЕОБРАЗОВАТЕЛЬНЫХ ШКОЛ // Известия ВГПУ. 2021. №10 (163). 
\bibitem{Ione} Серёгин, М. С. Использование платформы Arduino в образовательной деятельности / М. С. Серёгин // Инновационная наука. — 2019. — No 6. —С. 62–64.
\bibitem{Ione} Серёгин, М. С. Использование платформы Arduino в образовательной деятельности / М. С. Серёгин // Инновационная наука. — 2019. — No 6. —
С. 62–64.
\bibitem{Ione} Исходный код приложения Arduino IDE первой версии [Электронный ресурс]. — URL: \url{https://github.com/arduino/Arduino}
\bibitem{Ione} Исходный код приложения Arduino IDE современной версии [Электронный ресурс]. — URL: \url{https://github.com/arduino/arduino-ide}
\bibitem{Ione} Борис Черный. Профессиональный TypeScript. Разработка масштабируемых JavaScript-приложений. - СПб.: Питер, 2021. - 352 с.: ил. - (Серия “Бестселлеры O’Reily”)
\bibitem{Ione} Мардан Азат. React быстро. Веб-приложения на React, JSX, Redux и GraphQL. — СПб.: Питер, 2019. — 560 с.: ил. — (Серия «Библиотека программиста»). 
\bibitem{Ione} Исходный код приложения Arduino CLI [Электронный ресурс]. — URL: \url{https://github.com/arduino/arduino-cli}
\bibitem{Ione} Документация к приложению Arduino CLI [Электронный ресурс]. — URL: \url{https://arduino.github.io/arduino-cli/0.35/}
\bibitem{Ione} Оффициальный сайт протокола grpc [Электронный ресурс]. — URL: \url{https://grpc.io/}
\bibitem{Ione} Индрасири Касун, Курупу Данеш. gRPC: запуск и эксплуатация облачных приложений. Go и Java для Docker и Kubernetes. - СПб.: Питер, 2021. - 224с.: ил. - (Серия “Бестселлеры O’Reily”)
\end{thebibliography}

%\bibliographystyle{gost780uv}

%\bibliography{refs}
\appendix
\section{Исходный код dockerfile, унифицирующий настройки среды запуска системы тестирования}
\begin{Verbatim}[fontsize=\small, numbers=left]
FROM ubuntu

ARG path_to_tests_folder="./Tests"

LABEL EMAIL=gorka19800@gmail.com

#install all the necessary libs and apps
RUN apt-get update
RUN apt-get dist-upgrade -y
RUN echo "8"| apt-get install -y qttools5-dev-tools
RUN apt-get install -y git python3 cmake qtbase5-dev g++ libqt5svg5-dev
 libqt5x11extras5-dev qtscript5-dev libboost-system-dev zlib1g zlib1g-dev
#setup git
RUN git config --global user.email "gorka19800@gmail.com"
RUN git config --global user.name "Test suit"
#clone repo and prepare for building kumir-to-arduino translator
RUN mkdir /home/Sources
WORKDIR /home/Sources/
RUN git clone https://github.com/CaMoCBaJL/kumir2
WORKDIR kumir2/
RUN git pull
RUN git checkout translator_tests
RUN git merge -s ours --no-edit origin/ArduinoFixes
RUN mkdir build
WORKDIR build/
#build translator
RUN cmake -DUSE_QT=5 -DCMAKE_BUILD_TYPE=Release ..
RUN make -j 18
#start tests
WORKDIR ../kumir_tests/
RUN touch test_results.log
RUN python3 test_script.py -d -o ./test_results.log
-tr ../build/bin/kumir2-arduino -t \$path_to_tests_folder
\end{Verbatim}
\section{Исходный код скрипта, производящего тестирование транслятора}
\begin{Verbatim}[fontsize=\small, numbers=left]
import os
import sys
import subprocess

#constants
class CONSOLE_BG_COLORS:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class TEST_RESULT_STATE:
    COMPLETED = 1
    MISSING_EXPECTATION = 2
    COMPILER_ERROR_HAPPEND = 3
    FAILED = -1
    NONE = 0

COMPILER_ERROR_LABEL = "ERROR!"

EXPECTATION_FILE_EXTENTION = ".exp"
SOURCE_FILE_EXTENTION = ".kum"

CONTROL_CHARACTERS = ["\n", "\r", "\t", " "]
BYTES_TO_READ_COUNT = 1024
CHAR_THRESHOLD = 0.3
TEXT_CHARACTERS = ''.join(
    [chr(code) for code in range(32, 127)] +
    list('\b\f\n\r\t')
)
BINARY_CHAR_EXAMPLE = '\x00'

TESTS_FOLDER_NAME = "Tests"

ARGS = {"help": ["-h", "--help"],
        "translator": ["-tr", "--translator"],
        "output": ["-o", "--output"],
        "duplicate": ["-d", "--duplicate"],
        "skip-successfull": ["-ss", "--skip-successfull"],
        "skip-failed": ["-sf", "--skip-failed"],
        "skip-without-expectation": ["-swe", "--skip-without-expectation"],
        "skip-with-compiler-error": ["-sce", "--skip-with-compiler-error"],
        "brief": ["-b", "--brief"],
        "path-to-tests": ["-t", "path-to-tests"]
        }

ERRORS = {
    "wrong input": "Wrong args input - you should type path to file after -c or
     -o flags!",
    "file not exist": "File doesn't exist!",
    "wrong file extention": "File extention for translator is not correct! It should
     be a bin-file.",
    "no path to tests": "Wrong args input - you should type path to tests folder
     after -t flag!"
}

#data structure to store test results
class TestResult:

    __text_color = CONSOLE_BG_COLORS.OKGREEN
    __header_text = ""
    SKIPPED_TEST_TYPES = [TEST_RESULT_STATE.NONE]

    def __init__(self, name: str, source: str, expectation: str, result: str):
        self.name = name
        self.source_file_name = source
        self.expectation_file_name = expectation
        self.resultFileName = result
        self.state = TEST_RESULT_STATE.NONE

    def __str__(self):
        self.__setup_output()
        additional_test_data = f'''
        Test group expectations: {self.expectation_file_name}
        Test group results: {self.resultFileName}. 
        To get more detail info about comparison results, print:
        vimdiff {self.source_file_name} {self.expectation_file_name}
         {self.resultFileName}
        or vimdiff {self.expectation_file_name} {self.resultFileName}
        {CONSOLE_BG_COLORS.ENDC}
        '''
        return f'''{self.__text_color}
        Test {self.name}.
        {self.__header_text}
        Sources for the test: {self.source_file_name}
        {additional_test_data if self.state is TEST_RESULT_STATE.COMPLETED
         or self.state is TEST_RESULT_STATE.FAILED else ""}
        '''

    def __setup_output(self):
        if self.state == TEST_RESULT_STATE.COMPLETED:
            self.__text_color = CONSOLE_BG_COLORS.OKGREEN
            self.__header_text = "Congratulations! Test completed successfully!"
        elif self.state == TEST_RESULT_STATE.MISSING_EXPECTATION:
            self.__text_color = CONSOLE_BG_COLORS.OKCYAN
            self.__header_text = "Oh! Test didn't complete: no expectation"
        elif self.state == TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND:
            self.__text_color = CONSOLE_BG_COLORS.WARNING
            self.__header_text = "Oh! Test didn't complete: compiler error"
        elif self.state == TEST_RESULT_STATE.FAILED:
            self.__text_color = CONSOLE_BG_COLORS.FAIL
            self.__header_text = "Sorry, but test failed..."

class TestSection:

    def __init__(self, section_name) -> None:
        self.name = section_name
        self.test_results = []
    
    def __str__(self) -> str:
        columns, _ = os.get_terminal_size()
        if (len(self.test_results) > 0):
            return f"""
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            Test section {self.name} starts here:
            {os.linesep.join(list(map(lambda test_result: str(test_result),
             self.test_results)))}
            End of {self.name} section tests
            {CONSOLE_BG_COLORS.WARNING + "-" *columns + CONSOLE_BG_COLORS.ENDC}
            """
        
        return ''

#functions
def remove_control_characters(data_array):
    result = []
    for i in data_array:
        for cc in CONTROL_CHARACTERS:
            i = i.replace(cc, "")

        if i:
            result.append(i)

    return result

def get_file_data(filename):
    if not os.path.exists(filename):
        return ''
    file = open(filename, "r")
    result = file.readlines()
    file.close()
    return result

def has_errors(text):
    return COMPILER_ERROR_LABEL in text

def process_sources(source_filename, path_to_translator):
    path, _ = os.path.splitext(source_filename)
    result_filename = path + ".kumir.c"

    #call kumir2-arduino with params: 
    --out="path_to_cwd/results/test_name.kumir.c" -s ./test_name.kum
    popen = subprocess.Popen([path_to_translator,
                              f'--out={result_filename}',
                              '-s',
                              source_filename],
                             stdout=subprocess.PIPE)
    popen.wait()
    popen.stdout.read()

    return result_filename

def compare_data(expected_data, processed_data) -> TEST_RESULT_STATE:
    result_without_kumir_ref = remove_control_characters(processed_data[2:])
    expected_data = remove_control_characters(expected_data)

    if (has_errors(result_without_kumir_ref)):
        return TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND

    for i in range(len(result_without_kumir_ref)):
        if result_without_kumir_ref[i] != expected_data[i]:
            return TEST_RESULT_STATE.FAILED

    return TEST_RESULT_STATE.COMPLETED

def get_test_result_type_counters(test_sections):
    counters = {
        TEST_RESULT_STATE.COMPLETED: 0,
        TEST_RESULT_STATE.FAILED: 0,
        TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND: 0,
        TEST_RESULT_STATE.MISSING_EXPECTATION: 0,
    }

    for test_section in test_sections:
        for test_result in test_section.test_results:
            counters[test_result.state] += 1


    return counters

#log comparison results to file
def log_test_results(logs_filename, data_to_log: TestSection, log_to_console):
    result_type_counters = get_test_result_type_counters(data_to_log)
    completed_tests_count, failed_tests_count,
     compiler_error_happend_tests_count, 
     missing_expectations_tests_count = \
    [result_type_counters[k] for k in result_type_counters]

    log_data = []
    for test_section in data_to_log:
        test_section.test_results = list(filter
        (lambda test_result: test_result.state not in 
        TestResult.SKIPPED_TEST_TYPES, test_section.test_results))
        log_data.append(test_section)

    log_data_strings = list(map(lambda x: str(x), log_data))
    log_data_strings.insert(0, f'''
    There were found: {len(log_data)} tests.
    {CONSOLE_BG_COLORS.OKGREEN} Completed: 
    {completed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.FAIL} Failed: 
    {failed_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.WARNING} With compiler error happend:
     {compiler_error_happend_tests_count} {CONSOLE_BG_COLORS.ENDC}
    {CONSOLE_BG_COLORS.OKCYAN} Missed expectation file: 
    {missing_expectations_tests_count} {CONSOLE_BG_COLORS.ENDC}''')

    if not os.path.exists(logs_filename):
        open(logs_filename, "a").close()

    log_file = open(logs_filename, "a")
    log_file.writelines(log_data_strings)
    log_file.close()

    if log_to_console:
        print(f"{os.linesep}".join(log_data_strings))

def is_binary_file(filename):
    file_stream = open(filename, 'rb')
    file_content = file_stream.read(BYTES_TO_READ_COUNT)
    file_stream.close()
    
    if not len(file_content):
        #file is empty, nothing to read
        return False
    
    if ord(BINARY_CHAR_EXAMPLE) in file_content:
        #file contains binary symbols
        return True
    
    binary_chars = file_content.translate(TEXT_CHARACTERS)
    return float(len(binary_chars)) / len(file_content) > CHAR_THRESHOLD

def validate_file_name(filename: str, is_log_file: bool):   
    if not os.path.exists(filename):
        print(filename + ERRORS.get("file not exist"))
        sys.exit(2)
    if not os.path.isfile(filename):
        print(ERRORS.get("wrong input"))
        sys.exit(2)
    if not is_log_file and not is_binary_file(filename):
        print(ERRORS.get("wrong file extention"))
        sys.exit(2)
        
def show_help():
    print(""" kumir2-arduino tester.
    Description:
    Approach of this app is to debug the work of kumir2 
    to arduino translator. It uses compiled translator's 
    instance, pre-builded locally on PC.
    To start the work you should input path to compiler 
    and path to logs file.
    Flags:
    [-h] [--help] - show help.
    
    [-tr] [--translator] ["the path to pre-builded kumir2 
    to arduino translator instance"] - show app what 
    translator instance to use.
    
    [-t] [--path-to-tests] ["the path to tests folder"] = 
    show app  the folder with test files.
    
    [-o] [--output] ["the path to log file"] - show app 
    where to store test logs.
    
    [-d] [--duplicate] - duplicate output to console.

    [-ss] [--skip-successfull] - skip open log info about 
    succesfully completed tests.

    [-sf] [--skip-failed] - skip open log info about failed tests.

    [-swe] [--skip-without-expectation] - skip open log info 
    about tests for which the file with expectations 
    was not found.

    [-sce] [--skip-with-compiler-error] - skip open log info 
    about tests ended with compiler error.

    [-b] [--brief] - skip open log info about all tests.
    """)

def process_args():
    result = ["", "", False, ""]
    if ARGS["help"][0] in sys.argv or ARGS["help"][1] 
    in sys.argv:
        show_help()
        sys.exit(2)

    if ARGS["skip-successfull"][0] in sys.argv or ARGS["
    skip-successfull"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.COMPLETED)
    
    if ARGS["skip-without-expectation"][0] in sys.argv 
    or ARGS["skip-without-expectation"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT_STATE
        .MISSING_EXPECTATION)

    if ARGS["skip-with-compiler-error"][0] in sys.argv or
     ARGS["skip-with-compiler-error"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(TEST_RESULT
        _STATE.COMPILER_ERROR_HAPPEND)

    if ARGS["skip-failed"][0] in sys.argv or ARGS[
    "skip-failed"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES.append(
        TEST_RESULT_STATE.FAILED)

    if ARGS["brief"][0] in sys.argv or ARGS["brief"][1] in sys.argv: 
        TestResult.SKIPPED_TEST_TYPES = [
            TEST_RESULT_STATE.COMPILER_ERROR_HAPPEND, 
            TEST_RESULT_STATE.COMPLETED, 
            TEST_RESULT_STATE.FAILED,
            TEST_RESULT_STATE.MISSING_EXPECTATION
            ]

    args = sys.argv[1:]
    for i in range(1, len(args)):
        if args[i - 1] in ARGS["translator"] or args[i - 1]
         in ARGS["output"] or args[i - 1] in ARGS
         ["path-to-tests"]:
            if (os.path.isfile(args[i])):
                validate_file_name(args[i], False if args[i - 1]
                 in ARGS["translator"] else True)

            if args[i - 1] in ARGS["translator"]:
                result[0] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["output"]: 
                result[1] = os.path.abspath(args[i])
            elif args[i - 1] in ARGS["path-to-tests"]:
                result[3] = os.path.abspath(args[i])
        elif args[i-1] in ARGS["duplicate"]:              
            result[2] = True
            
    return result

def get_files_with_absolute_paths(folder_name):
    path_to_folder = os.path.join(os.getcwd(), folder_name)
    files = 
    list(map(lambda x: os.path.join(path_to_folder, x),
     os.listdir(path=path_to_folder)))
    files.sort()

    return files

def get_source_and_expectation(dir_files):
    sources = []
    expectations = []
    for file in dir_files:
        if (os.path.isfile(file)):
            ext = os.path.splitext(file)[1]
            if (ext == EXPECTATION_FILE_EXTENTION):
                expectations.append(file)
            elif (ext == SOURCE_FILE_EXTENTION):
                sources.append(file)
    
    return [sources, expectations]

def get_folder_contents_full_paths(path_to_folder):
    return list(
        map(
            lambda x: os.path.join(os.sep, path_to_folder, x),
            os.listdir(path_to_folder)
            )
        )

def calculate_test_sections(path_to_tests_folder):
    result = []
    test_folder_paths = get_folder_contents_full
    _paths(path_to_tests_folder)
    for test_folder_path in test_folder_paths:
        if os.path.isfile(test_folder_path):
            continue

        result.append(TestSection(test_folder_path.
        split(os.sep)[-1]))
        test_paths = get_folder_contents_full_paths
        (test_folder_path)
        for test_dir_path in test_paths:
            source_files, expectation_files =
          get_source_and_expectation(get_folder_contents_full_paths
            (test_dir_path))
            if os.path.isfile(test_dir_path) or len
            (expectation_files) > 1 or len(source_files)
             < 1:
                continue
            
            result[-1].test_results.append(TestResult(
                test_dir_path.split(os.sep)[-1],
                source_files[0],
                "", ""
                )
            )

            if len(expectation_files) == 1:
                result[-1].test_results[-1]
         .expectation_file_name  = expectation_files[0]
                result[-1].test_results[-1].resultFileName
                 = process_sources(source_files[0],
                  args_data[0])
                result_data = get_file_data(result[-1]
               
                .test_results[-1].resultFileName)
                expected_data =
     get_file_data(result[-1].test_results[-1].expectation_file_name)
                result[-1].test_results[-1].state 
                = compare_data(expected_data, result_data)
            else: 
                result[-1].test_results[-1].state = 
                TEST_RESULT_STATE.MISSING_EXPECTATION

    return result

if __name__=="__main__":
    args_data = process_args()

    if not args_data[3]:
        print("Didn't find any test to execute. Shutting down.")       
        sys.exit()

    test_results = calculate_test_sections(args_data[3])

    log_test_results(args_data[1], test_results, args_data[2])
\end{Verbatim}
\end{document}